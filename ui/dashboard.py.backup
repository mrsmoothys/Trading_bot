"""
Trading Dashboard - Fully Functional
Web-based dashboard with interactive charts, timeframe selection, and feature overlays.
"""

import asyncio
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import dash
from dash import dcc, html, Input, Output, State, callback, callback_context
from dash.exceptions import PreventUpdate
import dash_bootstrap_components as dbc
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, Any, Tuple, Optional, List
from loguru import logger
import os
import time
import requests
import json

# Global state for tracking selections
GLOBAL_STATE = {
    'selected_timeframe': '15m',
    'selected_symbol': 'BTCUSDT',
    'active_features': {
        'liquidity': True,
        'supertrend': True,
        'chandelier': True,
        'orderflow': True,
        'regime': True,
        'alignment': False
    }
}

DATA_CACHE: Dict[Tuple[str, str, int], Dict[str, Any]] = {}
CACHE_TTL_SECONDS = int(os.getenv('DASH_DATA_CACHE_TTL', '30'))
USE_SAMPLE_DATA = os.getenv('DASH_USE_SAMPLE_DATA', '0') == '1'  # Default to live data

LAST_TOGGLE = {'ts': 0.0}
REGIME_FEATURE_STRATEGY = {
    "TRENDING_HIGH_VOL": ["supertrend", "chandelier"],
    "TRENDING_LOW_VOL": ["supertrend"],
    "RANGING_COMPRESSION": ["liquidity", "orderflow"],
    "RANGING_EXPANSION": ["liquidity", "orderflow", "regime"],
    "TRANSITION": ["orderflow"],
}

CHAT_CLIENT = None
CHAT_SYSTEM_CONTEXT = None
CHAT_INIT_ERROR = None


def run_async_task(async_func, *args, **kwargs):
    """Execute an async callable from sync contexts with graceful fallback."""
    try:
        return asyncio.run(async_func(*args, **kwargs))
    except RuntimeError as exc:
        # Happens if another loop is already running
        if "asyncio.run()" in str(exc):
            loop = asyncio.new_event_loop()
            try:
                asyncio.set_event_loop(loop)
                return loop.run_until_complete(async_func(*args, **kwargs))
            finally:
                asyncio.set_event_loop(None)
                loop.close()
        raise


def initialize_chat_client():
    """Lazy-load DeepSeek chat client for dashboard interactions."""
    global CHAT_CLIENT, CHAT_SYSTEM_CONTEXT, CHAT_INIT_ERROR

    if CHAT_CLIENT or CHAT_INIT_ERROR:
        return CHAT_CLIENT

    try:
        from core.system_context import SystemContext
        CHAT_SYSTEM_CONTEXT = SystemContext()

        # Memory manager is optional for chat context optimization
        memory_manager = None
        try:
            from core.memory_manager import M1MemoryManager
            memory_manager = M1MemoryManager()
        except Exception as mem_err:
            logger.warning(f"Memory manager unavailable for chat context: {mem_err}")

        from deepseek.client import DeepSeekBrain
        CHAT_CLIENT = DeepSeekBrain(CHAT_SYSTEM_CONTEXT, memory_manager)
        logger.info("DeepSeek chat client initialized for dashboard")
    except Exception as exc:
        CHAT_INIT_ERROR = str(exc)
        CHAT_CLIENT = None
        logger.warning(f"DeepSeek AI chat unavailable: {exc}")

    return CHAT_CLIENT


def update_overlay_context(features: Dict[str, bool], timeframe: str):
    """Keep SystemContext overlay metadata in sync for richer chat context."""
    if not CHAT_SYSTEM_CONTEXT:
        return

    CHAT_SYSTEM_CONTEXT.overlay_state.update(features)
    CHAT_SYSTEM_CONTEXT.overlay_history.append({
        'timestamp': datetime.now().isoformat(),
        'timeframe': timeframe,
        'features': features.copy()
    })

    # Limit history to avoid unbounded growth
    if len(CHAT_SYSTEM_CONTEXT.overlay_history) > 50:
        CHAT_SYSTEM_CONTEXT.overlay_history = CHAT_SYSTEM_CONTEXT.overlay_history[-50:]


def gather_multi_timeframe_data(symbol: str, num_bars: int = 100) -> Dict[str, Any]:
    """Gather summarized data for multiple timeframes."""
    timeframes = ['1m', '5m', '15m', '1h', '4h', '1d']
    multi_tf_data = {}

    for tf in timeframes:
        try:
            # Fetch data for each timeframe
            df, meta = fetch_market_data(symbol, tf, num_bars=num_bars, force_refresh=False)

            if df is not None and len(df) > 0:
                # Calculate trend (simple slope of closing prices)
                recent_prices = df['close'].tail(20)
                trend_slope = (recent_prices.iloc[-1] - recent_prices.iloc[0]) / recent_prices.iloc[0] if len(recent_prices) > 1 else 0

                # Determine trend direction
                if trend_slope > 0.01:
                    trend = "BULLISH"
                elif trend_slope < -0.01:
                    trend = "BEARISH"
                else:
                    trend = "SIDEWAYS"

                # Calculate regime (simplified)
                returns = df['close'].pct_change()
                realized_vol = returns.rolling(20).std().fillna(0).iloc[-1] if len(df) > 20 else 0
                vol_threshold = returns.std() if len(returns) > 20 else 0

                if realized_vol > vol_threshold * 1.2:
                    regime = "HIGH_VOL"
                elif realized_vol < vol_threshold * 0.8:
                    regime = "LOW_VOL"
                else:
                    regime = "NORMAL_VOL"

                # Get current price level
                current_price = df['close'].iloc[-1]
                price_24h = df['close'].iloc[-25] if len(df) > 25 else df['close'].iloc[0]
                price_change_24h = ((current_price - price_24h) / price_24h) * 100 if price_24h != 0 else 0

                multi_tf_data[tf] = {
                    "trend": trend,
                    "regime": regime,
                    "current_price": round(current_price, 2),
                    "price_change_24h": round(price_change_24h, 2),
                    "volatility": round(realized_vol * 100, 2),
                    "bars_analyzed": len(df)
                }
            else:
                multi_tf_data[tf] = {
                    "trend": "UNKNOWN",
                    "regime": "UNKNOWN",
                    "current_price": 0,
                    "price_change_24h": 0,
                    "volatility": 0,
                    "bars_analyzed": 0
                }

        except Exception as e:
            logger.warning(f"Failed to fetch data for {tf}: {e}")
            multi_tf_data[tf] = {
                "trend": "ERROR",
                "regime": "ERROR",
                "current_price": 0,
                "price_change_24h": 0,
                "volatility": 0,
                "bars_analyzed": 0,
                "error": str(e)
            }

    return multi_tf_data


def build_chat_context(
    message_type: str = "strategy",
    chat_history: Optional[List[Dict[str, Any]]] = None
) -> Dict[str, Any]:
    """Create context payload for DeepSeek chat responses with multi-timeframe data."""
    current_tf = GLOBAL_STATE.get('selected_timeframe', '15m')
    symbol = GLOBAL_STATE.get('selected_symbol', 'BTCUSDT')
    logger.info(f"[DIAGNOSTIC] build_chat_context called - Using timeframe: {current_tf}, Message type: {message_type}")

    # Gather multi-timeframe data
    multi_tf_data = gather_multi_timeframe_data(symbol)

    conversation_history: List[Dict[str, Any]] = []
    if chat_history:
        for msg in chat_history[-10:]:
            conversation_history.append({
                "role": "user" if msg.get('is_user', True) else "assistant",
                "text": msg.get('text', ''),
                "timestamp": msg.get('timestamp', '')
            })

    context = {
        "message_type": message_type,
        "dashboard_state": {
            "symbol": symbol,
            "timeframe": current_tf,
            "active_features": GLOBAL_STATE['active_features'],
            "timestamp": datetime.now().isoformat(),
            "multi_timeframe_summary": multi_tf_data
        }
    }

    if conversation_history:
        context["conversation_history"] = conversation_history

    if CHAT_SYSTEM_CONTEXT:
        context["system_state"] = CHAT_SYSTEM_CONTEXT.get_context_for_deepseek()

    logger.info(f"[DIAGNOSTIC] Chat context payload timeframe: {context['dashboard_state']['timeframe']} with {len(multi_tf_data)} timeframe summaries")
    return context


def create_feature_metrics_table(
    metrics: Dict[str, Dict[str, Any]],
    current_regime: str = "UNKNOWN",
    recommendations: List[str] = None
) -> html.Div:
    """Render telemetry table for feature latency/memory usage."""
    if not metrics:
        return html.Div(
            "Telemetry pending â€” run the trading loop to capture feature metrics.",
            style={'color': '#666', 'fontStyle': 'italic', 'padding': '10px'}
        )

    header = html.Tr([
        html.Th("Feature"),
        html.Th("Latency (ms)"),
        html.Th("Memory Î” (MB)"),
        html.Th("Timestamp")
    ])
    rows = []
    for name, data in metrics.items():
        rows.append(html.Tr([
            html.Td(name.title()),
            html.Td(f"{data.get('latency_ms', 0):.2f}"),
            html.Td(f"{data.get('memory_delta_mb', 0):.2f}"),
            html.Td(data.get('timestamp', '').split('T')[0])
        ]))

    table = html.Table([header] + rows, style={
        'width': '100%',
        'borderCollapse': 'collapse',
        'fontSize': '13px'
    })
    overlay_text = ', '.join(recommendations) if recommendations else 'None'
    extra = html.P(
        f"Current regime: {current_regime} | Recommended overlays: {overlay_text}",
        style={'color': '#666', 'fontSize': '12px', 'marginTop': '10px'}
    )
    return html.Div([table, extra])


def call_deepseek_chat(
    user_message: str,
    message_type: str = "strategy",
    chat_history: Optional[List[Dict[str, Any]]] = None
) -> Tuple[str, str]:
    """
    Invoke DeepSeek chat interface and return (response text, status label).
    Falls back to informative message when AI isn't available.
    """
    chat_client = initialize_chat_client()

    if not chat_client:
        return generate_demo_chat_response(user_message, message_type, CHAT_INIT_ERROR)

    try:
        context = build_chat_context(message_type, chat_history)
        response = run_async_task(
            chat_client.chat_interface,
            user_message,
            context,
            message_type
        )
        if isinstance(response, str) and not response.lower().startswith("sorry, i encountered an error"):
            return response, "DeepSeek AI response âœ“"

        logger.warning(f"DeepSeek returned error payload, switching to demo response: {response}")
        return generate_demo_chat_response(user_message, message_type, "DeepSeek API error")
    except Exception as exc:
        error_msg = f"DeepSeek AI error: {exc}"
        logger.error(error_msg)
        return generate_demo_chat_response(user_message, message_type, str(exc))


def generate_demo_chat_response(message_text: str, message_type: str, reason: Optional[str] = None) -> Tuple[str, str]:
    """Build a helpful fallback response when DeepSeek is unavailable."""
    status_reason = reason or CHAT_INIT_ERROR or "DeepSeek configuration missing"
    symbol = GLOBAL_STATE.get('selected_symbol', 'BTCUSDT')
    timeframe = GLOBAL_STATE.get('selected_timeframe', '15m')
    features = [name for name, enabled in GLOBAL_STATE.get('active_features', {}).items() if enabled]

    summary = [
        f"DeepSeek AI is currently unavailable ({status_reason}).",
        "This is a demo response so you can keep testing the UI.",
        "",
        f"- Symbol: {symbol}",
        f"- Timeframe: {timeframe}",
        f"- Active overlays: {', '.join(features) if features else 'none'}",
        "",
        "Requested message:",
        message_text
    ]

    if CHAT_SYSTEM_CONTEXT:
        perf = CHAT_SYSTEM_CONTEXT.get_performance_summary()
        summary.extend([
            "",
            "Recent system state:",
            f"â€¢ Total trades: {perf.get('total_trades', 0)}",
            f"â€¢ Win rate: {perf.get('win_rate', 0):.2%}",
            f"â€¢ Max drawdown: {perf.get('max_drawdown', 0):.2%}"
        ])

    return "\n".join(summary), "Demo response âœ“"


def render_chat_history(chat_history):
    """Convert chat history into Dash components."""
    components = []
    for msg in chat_history[-50:]:
        if msg.get('is_user', True):
            components.append(
                html.Div([
                    html.Div("You", style={'fontWeight': 'bold', 'marginBottom': '5px', 'color': '#00ff88'}),
                    html.Div(msg.get('text', ''), style={
                        'backgroundColor': '#1a1a1a',
                        'padding': '10px',
                        'borderRadius': '8px',
                        'maxWidth': '70%',
                        'marginLeft': 'auto'
                    }),
                    html.Div(msg.get('timestamp', ''), style={
                        'fontSize': '10px',
                        'color': '#666',
                        'marginTop': '5px',
                        'textAlign': 'right'
                    })
                ], style={'textAlign': 'right', 'marginBottom': '15px'})
            )
        else:
            components.append(
                html.Div([
                    html.Div("DeepSeek AI", style={'fontWeight': 'bold', 'marginBottom': '5px', 'color': '#4488ff'}),
                    html.Div(msg.get('text', ''), style={
                        'backgroundColor': '#1a1a1a',
                        'padding': '15px',
                        'borderRadius': '8px',
                        'maxWidth': '70%',
                        'borderLeft': '3px solid #4488ff'
                    }),
                    html.Div(msg.get('timestamp', ''), style={'fontSize': '10px', 'color': '#666', 'marginTop': '5px'})
                ], style={'marginBottom': '15px'})
            )

    return components


def process_chat_request(
    chat_history,
    message_text: str,
    message_type: str = "strategy",
    status_prefix: str = "Message sent"
):
    """Handle chat exchange with DeepSeek and return updated history + status."""
    chat_history = chat_history or []
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Log the chat request with current timeframe context
    current_tf = GLOBAL_STATE.get('selected_timeframe', 'UNKNOWN')
    logger.info(f"[DIAGNOSTIC] Processing chat request - Type: {message_type}, Timeframe in context: {current_tf}, Message: {message_text[:50]}...")

    user_message = {
        'is_user': True,
        'text': message_text,
        'timestamp': timestamp
    }
    save_chat_to_log(user_message)

    # Pass current chat_history (before adding user/ai messages) to DeepSeek
    ai_text, ai_status = call_deepseek_chat(message_text, message_type, chat_history)
    ai_message = {
        'is_user': False,
        'text': ai_text,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    save_chat_to_log(ai_message)

    # Create updated history with both user and AI messages
    updated_history = chat_history + [user_message, ai_message]

    # Also update SystemContext conversation_memory for DeepSeek memory
    if CHAT_SYSTEM_CONTEXT:
        CHAT_SYSTEM_CONTEXT.add_conversation_message(
            user_message['text'],
            ai_text,
            message_type
        )

    status = f"{status_prefix}: {ai_status} | Logged to: logs/chat_history.log"
    logger.info(f"[DIAGNOSTIC] Chat response generated with timeframe context: {current_tf}")
    return updated_history, render_chat_history(updated_history), status


def parse_backtest_command(message_text: str) -> Optional[Dict[str, Any]]:
    """Parse natural language backtest command from chat.

    Examples:
    - "run backtest BTCUSDT 1h convergence"
    - "run backtest symbol=ETHUSDT timeframe=15m strategy=sma"
    - "backtest BTC on 4h with macd strategy"
    """
    import re

    message_lower = message_text.lower()

    # Check if this is a backtest command
    if not ('backtest' in message_lower or 'test strategy' in message_lower):
        return None

    config = {
        'symbol': 'BTCUSDT',  # defaults
        'timeframe': '1h',
        'strategy': 'convergence',
        'start': (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'),
        'end': datetime.now().strftime('%Y-%m-%d'),
        'initial_capital': 10000.0
    }

    # Extract symbol
    symbol_pattern = r'(BTCUSDT|ETHUSDT|SOLUSDT|BTC|ETH|SOL)'
    symbol_match = re.search(symbol_pattern, message_text, re.IGNORECASE)
    if symbol_match:
        sym = symbol_match.group(1).upper()
        if sym in ['BTC', 'ETH', 'SOL']:
            sym += 'USDT'
        config['symbol'] = sym

    # Extract timeframe
    tf_pattern = r'\b(1m|5m|15m|1h|4h|1d)\b'
    tf_match = re.search(tf_pattern, message_text, re.IGNORECASE)
    if tf_match:
        config['timeframe'] = tf_match.group(1).lower()

    # Extract strategy
    strategy_pattern = r'(convergence|sma|rsi|macd)'
    strategy_match = re.search(strategy_pattern, message_text, re.IGNORECASE)
    if strategy_match:
        config['strategy'] = strategy_match.group(1).lower()

    # Extract capital if specified
    capital_pattern = r'(?:capital|money|funds?)\s+(?:of\s+)?[$]?(\d+(?:,\d{3})*(?:\.\d+)?)'
    capital_match = re.search(capital_pattern, message_text, re.IGNORECASE)
    if capital_match:
        config['initial_capital'] = float(capital_match.group(1).replace(',', ''))

    return config


def call_backtest_api(config: Dict[str, Any]) -> Dict[str, Any]:
    """Call the backtest API endpoint."""
    try:
        response = requests.post(
            'http://localhost:8000/backtest',
            json=config,
            timeout=30
        )

        if response.status_code == 200:
            return response.json()
        else:
            return {
                'success': False,
                'error': f"API error: {response.status_code} - {response.text}"
            }
    except requests.exceptions.ConnectionError:
        return {
            'success': False,
            'error': "Cannot connect to backtest API. Make sure it's running on localhost:8000"
        }
    except Exception as e:
        return {
            'success': False,
            'error': f"Error calling backtest API: {str(e)}"
        }


def format_backtest_chat_response(config: Dict[str, Any], api_response: Dict[str, Any]) -> str:
    """Format backtest results for chat display."""
    if not api_response.get('success', False):
        error = api_response.get('error', 'Unknown error')
        return f"âŒ Backtest failed: {error}"

    result = api_response.get('result', {})

    # Format results as markdown
    response_lines = [
        f"âœ… Backtest completed for {config['symbol']} on {config['timeframe']} timeframe",
        f"Strategy: {config['strategy'].upper()}",
        f"Period: {config['start']} to {config['end']}",
        "",
        "**Results:**",
        f"â€¢ Total Return: {result.get('total_return_pct', 0):+.2f}%",
        f"â€¢ Sharpe Ratio: {result.get('sharpe_ratio', 0):.3f}",
        f"â€¢ Max Drawdown: {result.get('max_drawdown', 0):.2f}%",
        f"â€¢ Win Rate: {result.get('win_rate', 0):.1f}%",
        f"â€¢ Total Trades: {result.get('total_trades', 0)}",
        "",
        f"**Capital:**",
        f"â€¢ Initial: ${config['initial_capital']:,.2f}",
        f"â€¢ Final: ${result.get('final_capital', 0):,.2f}",
        f"â€¢ Profit Factor: {result.get('profit_factor', 0):.2f}",
        "",
        "ðŸ’¡ This backtest has been saved to the experiment database."
    ]

    if api_response.get('config_hash'):
        response_lines.append(f"Config hash: {api_response['config_hash'][:8]}...")

    return "\n".join(response_lines)


def process_chat_request(
    chat_history,
    message_text: str,
    message_type: str = "strategy",
    status_prefix: str = "Message sent"
):
    """Handle chat exchange with DeepSeek and return updated history + status."""
    chat_history = chat_history or []
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Log the chat request with current timeframe context
    current_tf = GLOBAL_STATE.get('selected_timeframe', 'UNKNOWN')
    logger.info(f"[DIAGNOSTIC] Processing chat request - Type: {message_type}, Timeframe in context: {current_tf}, Message: {message_text[:50]}...")

    user_message = {
        'is_user': True,
        'text': message_text,
        'timestamp': timestamp
    }
    save_chat_to_log(user_message)

    # Pass current chat_history (before adding user/ai messages) to DeepSeek
    ai_text, ai_status = call_deepseek_chat(message_text, message_type, chat_history)
    ai_message = {
        'is_user': False,
        'text': ai_text,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    save_chat_to_log(ai_message)

    # Create updated history with both user and AI messages
    updated_history = chat_history + [user_message, ai_message]

    # Also update SystemContext conversation_memory for DeepSeek memory
    if CHAT_SYSTEM_CONTEXT:
        CHAT_SYSTEM_CONTEXT.add_conversation_message(
            user_message['text'],
            ai_text,
            message_type
        )

    status = f"{status_prefix}: {ai_status} | Logged to: logs/chat_history.log"
    logger.info(f"[DIAGNOSTIC] Chat response generated with timeframe context: {current_tf}")
    return updated_history, render_chat_history(updated_history), status

def generate_sample_data(symbol: str, timeframe: str, num_bars: int = 200) -> pd.DataFrame:
    """Generate realistic sample OHLCV data for testing."""
    # Set parameters based on symbol and timeframe
    base_price = {
        'BTCUSDT': 100000,
        'ETHUSDT': 3000,
        'SOLUSDT': 150
    }.get(symbol, 100000)

    # Time delta based on timeframe
    time_deltas = {
        '1m': timedelta(minutes=1),
        '5m': timedelta(minutes=5),
        '15m': timedelta(minutes=15),
        '1h': timedelta(hours=1),
        '4h': timedelta(hours=4),
        '1d': timedelta(days=1)
    }
    td = time_deltas.get(timeframe, timedelta(minutes=15))

    # Generate timestamps
    end_time = datetime.now()
    start_time = end_time - (num_bars * td)
    timestamps = pd.date_range(start=start_time, end=end_time, periods=num_bars)

    # Generate price data with random walk
    # IMPORTANT: Use stable seed based on symbol (NOT timeframe) for consistent price levels
    np.random.seed(42)  # Fixed seed for reproducible data
    returns = np.random.normal(0.001, 0.02, num_bars)  # Small positive drift with volatility
    prices = base_price * (1 + returns).cumprod()

    # Generate OHLC from close prices
    opens = prices.copy()
    highs = np.maximum(opens, prices) * (1 + np.abs(np.random.normal(0, 0.01, num_bars)))
    lows = np.minimum(opens, prices) * (1 - np.abs(np.random.normal(0, 0.01, num_bars)))
    closes = prices

    # Generate volume (higher volume on larger moves)
    price_changes = np.abs(np.diff(np.concatenate([[opens[0]], closes])))
    volumes = np.random.lognormal(4, 1, num_bars) * (1 + price_changes * 5)

    return pd.DataFrame({
        'timestamp': timestamps,
        'open': opens,
        'high': highs,
        'low': lows,
        'close': closes,
        'volume': volumes
    })


async def get_real_market_data(symbol: str, timeframe: str, num_bars: int = 200) -> Tuple[pd.DataFrame, bool]:
    """Fetch real market data from Binance demo API with DataStore caching.

    Returns:
        Tuple containing the dataframe and a flag indicating if sample data was used.
    """
    used_sample_data = False
    try:
        from core.data.binance_client import BinanceClient
        from core.data.data_store import DataStore

        # Initialize DataStore
        data_store = DataStore()

        # Create cache key
        cache_key = f"ohlcv:{symbol}:{timeframe}"

        # Try to get from DataStore first (with get_or_fetch pattern)
        async def fetch_data():
            client = BinanceClient()
            ohlcv_data = await client.get_ohlcv(symbol, timeframe, limit=num_bars)
            if ohlcv_data is not None and len(ohlcv_data) > 0:
                # Store in DataStore
                await data_store.store_ohlcv(symbol, timeframe, ohlcv_data)
                logger.info(f"Fetched {len(ohlcv_data)} bars from Binance and cached")
                return ohlcv_data
            return None

        # Use get_or_fetch to check cache and fetch if needed
        ohlcv_data = await data_store.get_or_fetch(cache_key, fetch_data, ttl=60)

        if ohlcv_data is not None and len(ohlcv_data) > 0:
            return ohlcv_data, used_sample_data
        else:
            logger.warning("Failed to fetch real data, falling back to sample data")

    except Exception as e:
        logger.error(f"Error fetching real market data: {e}")
        logger.info("Falling back to sample data")

    used_sample_data = True
    return generate_sample_data(symbol, timeframe, num_bars), used_sample_data


# Timeframe to minutes mapping for freshness checks
TF_MINUTES = {
    '1m': 1,
    '3m': 3,
    '5m': 5,
    '15m': 15,
    '30m': 30,
    '1h': 60,
    '2h': 120,
    '4h': 240,
    '6h': 360,
    '8h': 480,
    '12h': 720,
    '1d': 1440,
    '3d': 4320,
    '1w': 10080
}

def fetch_market_data(symbol: str, timeframe: str, num_bars: int = 200, force_refresh: bool = False) -> Tuple[pd.DataFrame, Dict[str, Any]]:
    """
    Retrieve market data with caching and freshness-aware fetching.

    Returns:
        Tuple of (dataframe, metadata dict)
    """
    key = (symbol, timeframe, num_bars)
    now = datetime.now()
    cached_entry = DATA_CACHE.get(key)

    # Always clear cache if force_refresh is True
    if force_refresh and cached_entry:
        logger.debug(f"Cache cleared for {symbol}-{timeframe}")
        DATA_CACHE.pop(key, None)
        cached_entry = None

    # Check in-memory cache first
    if cached_entry and not force_refresh:
        age = (now - cached_entry['timestamp']).total_seconds()
        if age < CACHE_TTL_SECONDS:
            logger.debug(
                f"Memory cache hit for {symbol}-{timeframe} ({age:.1f}s old)"
            )
            return cached_entry['df'].copy(), {
                'cache_hit': True,
                'used_sample_data': cached_entry['used_sample_data']
            }

    df = None
    used_sample_data = USE_SAMPLE_DATA

    # Try to get from DataStore if not using sample data only
    if not USE_SAMPLE_DATA:
        try:
            from core.data.data_store import DataStore

            # Get or create DataStore instance
            if not hasattr(fetch_market_data, '_datastore'):
                fetch_market_data._datastore = DataStore(cache_dir='data/cache')
                logger.info("DataStore initialized for dashboard")

            datastore = fetch_market_data._datastore

            # Try to get from DataStore cache or Parquet
            if force_refresh:
                df = datastore.get_historical_data(symbol, timeframe, force_refresh=True)
            else:
                df = datastore.get_historical_data(symbol, timeframe)

            # If we have data from DataStore, use it
            if df is not None and len(df) > 0:
                # Limit to requested number of bars
                df = df.tail(num_bars).reset_index(drop=True)

                # Check if data is stale (P1.1: Freshness detection)
                is_stale = False
                if not used_sample_data and len(df) > 0:
                    # Get last candle timestamp
                    last_timestamp = pd.to_datetime(df['timestamp'].iloc[-1])
                    now_utc = datetime.now(timezone.utc)
                    age_delta = (now_utc - last_timestamp).total_seconds() / 60  # Convert to minutes

                    # Get expected timeframe duration
                    tf_minutes = TF_MINUTES.get(timeframe, 60)
                    # Data is stale if it's older than 2x the timeframe (allowing for exchange delay)
                    stale_threshold = tf_minutes * 2
                    is_stale = age_delta > stale_threshold

                    logger.info(
                        f"Data freshness check: {symbol} {timeframe} - "
                        f"Last candle age: {age_delta:.1f}m, Stale threshold: {stale_threshold:.1f}m, "
                        f"Stale: {is_stale}"
                    )

                    # If stale, force a fresh fetch from Binance
                    if is_stale and not force_refresh:
                        logger.warning(
                            f"Data is stale (age: {age_delta:.1f}m), refreshing {symbol} {timeframe} from Binance"
                        )
                        df, live_fetch_used_sample = run_async_task(
                            get_real_market_data,
                            symbol,
                            timeframe,
                            num_bars=num_bars
                        )
                        if df is not None and len(df) > 0:
                            df = df.tail(num_bars).reset_index(drop=True)
                            used_sample_data = live_fetch_used_sample
                            logger.info(
                                f"Refreshed {symbol} {timeframe} from Binance - "
                                f"Last candle: {pd.to_datetime(df['timestamp'].iloc[-1])}, "
                                f"Total candles: {len(df)}"
                            )
                            # Persist fresh data to DataStore
                            try:
                                run_async_task(
                                    datastore.store_ohlcv,
                                    symbol,
                                    timeframe,
                                    df
                                )
                                logger.info(f"Persisted fresh {symbol} {timeframe} data to DataStore")
                            except Exception as e:
                                logger.warning(f"Failed to persist fresh data to DataStore: {e}")

                logger.info(f"Loaded {len(df)} candles from DataStore for {symbol} {timeframe} (stale_check={is_stale})")
                used_sample_data = False
            else:
                # DataStore doesn't have data, fetch from Binance
                logger.info(f"No data in DataStore for {symbol} {timeframe}, fetching from Binance")
                df, live_fetch_used_sample = run_async_task(
                    get_real_market_data,
                    symbol,
                    timeframe,
                    num_bars=num_bars
                )
                used_sample_data = live_fetch_used_sample
                # Persist fresh data to DataStore
                if df is not None and len(df) > 0 and not used_sample_data:
                    try:
                        run_async_task(
                            datastore.store_ohlcv,
                            symbol,
                            timeframe,
                            df
                        )
                        logger.info(f"Persisted initial {symbol} {timeframe} data to DataStore")
                    except Exception as e:
                        logger.warning(f"Failed to persist data to DataStore: {e}")

        except Exception as e:
            logger.warning(f"DataStore/Binance fetch failed, using sample data: {e}")
            df = None
            used_sample_data = True
    else:
        logger.debug("DASH_USE_SAMPLE_DATA enabled - skipping real API calls")

    # Fallback to sample data if needed
    if df is None:
        logger.info(f"Using sample data for {symbol} {timeframe}")
        df = generate_sample_data(symbol, timeframe, num_bars=num_bars)
        used_sample_data = True

    # Update in-memory cache
    DATA_CACHE[key] = {
        'df': df.copy(),
        'timestamp': now,
        'used_sample_data': used_sample_data,
        'freshness_checked': True,
        'is_stale': is_stale if 'is_stale' in locals() else False
    }

    # Calculate last candle age for metadata
    last_candle_age_min = 0
    if df is not None and len(df) > 0:
        last_timestamp = pd.to_datetime(df['timestamp'].iloc[-1])
        last_candle_age_min = (datetime.now(timezone.utc) - last_timestamp).total_seconds() / 60

    logger.debug(
        f"Returning data for {symbol}-{timeframe}: {len(df)} candles, "
        f"sample_data={used_sample_data}, cache_hit=False, last_age={last_candle_age_min:.1f}m"
    )
    return df.copy(), {
        'cache_hit': False,
        'used_sample_data': used_sample_data,
        'last_candle_age_min': last_candle_age_min,
        'is_stale': is_stale if 'is_stale' in locals() else False,
        'tf_minutes': TF_MINUTES.get(timeframe, 60)
    }


def calculate_supertrend(df: pd.DataFrame, period: int = 10, multiplier: float = 3.0) -> Dict[str, Any]:
    """Calculate Supertrend indicator."""
    close = df['close']
    high = df['high']
    low = df['low']

    # Calculate ATR
    tr1 = high - low
    tr2 = abs(high - close.shift())
    tr3 = abs(low - close.shift())
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(period).mean()

    # Calculate HL2
    hl2 = (high + low) / 2

    # Calculate Upper and Lower bands
    upper_band = hl2 + (multiplier * atr)
    lower_band = hl2 - (multiplier * atr)

    # Calculate Supertrend
    supertrend = pd.Series(index=df.index, dtype=float)
    direction = pd.Series(index=df.index, dtype=int)  # 1 for uptrend, -1 for downtrend

    supertrend.iloc[0] = upper_band.iloc[0]
    direction.iloc[0] = 1

    for i in range(1, len(df)):
        if close.iloc[i] > supertrend.iloc[i-1]:
            direction.iloc[i] = 1
            supertrend.iloc[i] = max(lower_band.iloc[i], supertrend.iloc[i-1])
        else:
            direction.iloc[i] = -1
            supertrend.iloc[i] = min(upper_band.iloc[i], supertrend.iloc[i-1])

    return {
        'supertrend': supertrend,
        'direction': direction,
        'atr': atr
    }


def calculate_chandelier_exit(df: pd.DataFrame, period: int = 22, multiplier: float = 3.0) -> Dict[str, Any]:
    """Calculate Chandelier Exit indicator."""
    close = df['close']
    high = df['high']
    low = df['low']

    # Calculate ATR
    tr1 = high - low
    tr2 = abs(high - close.shift())
    tr3 = abs(low - close.shift())
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(period).mean()

    # Calculate Chandelier Exit
    long_exit = high.rolling(period).max() - (multiplier * atr)
    short_exit = low.rolling(period).min() + (multiplier * atr)

    return {
        'long_exit': long_exit,
        'short_exit': short_exit,
        'atr': atr
    }


def calculate_liquidity_zones(df: pd.DataFrame, lookback: int = 100) -> Dict[str, Any]:
    """Calculate liquidity zones (areas of high volume)."""
    typical_price = (df['high'] + df['low'] + df['close']) / 3
    volume = df['volume']

    # Create price bins
    price_min = df['low'].min()
    price_max = df['high'].max()
    price_bins = np.linspace(price_min, price_max, 20)

    volume_at_price = np.zeros(len(price_bins) - 1)

    # Aggregate volume at each price level
    for i, row in df.iterrows():
        low = row['low']
        high = row['high']
        vol = row['volume']

        for j in range(len(price_bins) - 1):
            bin_low = price_bins[j]
            bin_high = price_bins[j + 1]
            if high < bin_low or low > bin_high:
                continue
            overlap = (min(high, bin_high) - max(low, bin_low)) / (high - low)
            volume_at_price[j] += vol * overlap

    # Find significant zones (top 20% of volume)
    threshold = np.percentile(volume_at_price, 80)
    significant_zones = price_bins[:-1][volume_at_price > threshold]

    return {
        'zones': significant_zones,
        'volume_profile': dict(zip(price_bins[:-1], volume_at_price))
    }


def calculate_market_regime_overlay(df: pd.DataFrame, short_window: int = 20,
                                    long_window: int = 60) -> Dict[str, Any] | None:
    """Classify market regime for shading overlays."""
    if len(df) < long_window:
        return None

    returns = df['close'].pct_change()
    realized_vol = returns.rolling(long_window).std().fillna(0)
    vol_threshold = realized_vol.median()
    sma_short = df['close'].rolling(short_window).mean()
    sma_long = df['close'].rolling(long_window).mean()
    trend_strength = (sma_short - sma_long).fillna(0)

    regime_series = pd.Series('RANGING_LOW_VOL', index=df.index)
    regime_series[(trend_strength > 0) & (realized_vol >= vol_threshold)] = 'TRENDING_UP_HIGH_VOL'
    regime_series[(trend_strength > 0) & (realized_vol < vol_threshold)] = 'TRENDING_UP_LOW_VOL'
    regime_series[(trend_strength < 0) & (realized_vol >= vol_threshold)] = 'TRENDING_DOWN_HIGH_VOL'
    regime_series[(trend_strength < 0) & (realized_vol < vol_threshold)] = 'TRENDING_DOWN_LOW_VOL'

    colors = {
        'TRENDING_UP_HIGH_VOL': 'rgba(0, 255, 136, 0.08)',
        'TRENDING_UP_LOW_VOL': 'rgba(0, 136, 255, 0.08)',
        'TRENDING_DOWN_HIGH_VOL': 'rgba(255, 68, 68, 0.12)',
        'TRENDING_DOWN_LOW_VOL': 'rgba(255, 165, 0, 0.1)',
        'RANGING_LOW_VOL': 'rgba(255, 255, 255, 0.03)'
    }

    return {
        'series': regime_series,
        'colors': colors
    }


def calculate_timeframe_alignment(df: pd.DataFrame) -> Dict[str, pd.Series] | None:
    """Compute multi-EMA alignment signals for overlay markers."""
    if len(df) < 55:
        return None

    ema_fast = df['close'].ewm(span=10, adjust=False).mean()
    ema_mid = df['close'].ewm(span=21, adjust=False).mean()
    ema_slow = df['close'].ewm(span=55, adjust=False).mean()

    bullish = (ema_fast > ema_mid) & (ema_mid > ema_slow)
    bearish = (ema_fast < ema_mid) & (ema_mid < ema_slow)

    return {
        'bullish': bullish.fillna(False),
        'bearish': bearish.fillna(False)
    }


def create_interactive_chart(df: pd.DataFrame, symbol: str, timeframe: str,
                            features: Dict[str, Any]) -> go.Figure:
    """Create an interactive TradingView-style chart with feature overlays."""
    show_order_flow = features.get('orderflow', True)
    orderflow_height = 0.15 if show_order_flow else 0.01
    orderflow_title = 'Order Flow Imbalance' if show_order_flow else 'Order Flow (disabled)'

    # Create subplots
    fig = make_subplots(
        rows=3,
        cols=1,
        shared_xaxes=True,
        vertical_spacing=0.02,
        row_heights=[0.7, 0.15, orderflow_height],
        subplot_titles=(
            f'{symbol} - {timeframe.upper()} Timeframe',
            'Volume',
            orderflow_title
        )
    )

    # Add candlestick chart
    fig.add_trace(
        go.Candlestick(
            x=df['timestamp'],
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close'],
            name=symbol,
            increasing_line_color='#00ff88',
            decreasing_line_color='#ff4444',
            increasing_fillcolor='#00ff88',
            decreasing_fillcolor='#ff4444',
            line=dict(width=1)
        ),
        row=1, col=1
    )

    # Add Supertrend if enabled
    if features.get('supertrend', False):
        st_data = calculate_supertrend(df)
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=st_data['supertrend'],
                name='Supertrend',
                line=dict(color='#4488ff', width=2, dash='solid'),
                opacity=0.8
            ),
            row=1, col=1
        )

    # Add Chandelier Exit if enabled
    if features.get('chandelier', False):
        ce_data = calculate_chandelier_exit(df)
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=ce_data['long_exit'],
                name='Chandelier Long',
                line=dict(color='#ff9900', width=1, dash='dash'),
                opacity=0.7
            ),
            row=1, col=1
        )
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=ce_data['short_exit'],
                name='Chandelier Short',
                line=dict(color='#ff9900', width=1, dash='dash'),
                opacity=0.7
            ),
            row=1, col=1
        )

    # Add Liquidity Zones if enabled
    if features.get('liquidity', False):
        lz_data = calculate_liquidity_zones(df)
        zones = lz_data.get('zones', [])

        if len(zones) > 0:
            logger.debug(f"Drawing {len(zones)} liquidity zones")

            # Draw horizontal lines for each liquidity zone
            for zone in zones:
                fig.add_hline(
                    y=zone,
                    line=dict(color='rgba(255, 215, 0, 0.8)', width=2, dash='dash'),
                    layer='above',
                    annotation_text=f"Liquidity Zone: {zone:.2f}",
                    annotation_position="top left",
                    annotation=dict(font_size=10, font_color='rgba(255, 215, 0, 0.9)')
                )

            # Draw rectangular shading for each zone (wider for better visibility)
            for zone in zones:
                fig.add_vrect(
                    x0=df['timestamp'].iloc[0],
                    x1=df['timestamp'].iloc[-1],
                    y0=zone * 0.99,
                    y1=zone * 1.01,
                    fillcolor='rgba(255, 215, 0, 0.15)',
                    line_width=1,
                    line_color='rgba(255, 215, 0, 0.4)',
                    layer='below'
                )
        else:
            logger.debug("No significant liquidity zones detected")

    # Add market regime shading
    if features.get('regime', False):
        regime_data = calculate_market_regime_overlay(df)
        if regime_data:
            timestamps = df['timestamp']
            regimes = regime_data['series']
            colors = regime_data['colors']
            current_regime = regimes.iloc[0]
            segment_start = timestamps.iloc[0]

            for idx in range(1, len(timestamps)):
                if regimes.iloc[idx] != current_regime:
                    fig.add_vrect(
                        x0=segment_start,
                        x1=timestamps.iloc[idx],
                        fillcolor=colors.get(current_regime, 'rgba(255,255,255,0.03)'),
                        line_width=0,
                        layer='below'
                    )
                    current_regime = regimes.iloc[idx]
                    segment_start = timestamps.iloc[idx]

            # Add final segment
            fig.add_vrect(
                x0=segment_start,
                x1=timestamps.iloc[-1],
                fillcolor=colors.get(current_regime, 'rgba(255,255,255,0.03)'),
                line_width=0,
                layer='below'
            )

            last_regime_raw = regimes.iloc[-1]
            latest_regime = last_regime_raw.replace('_', ' ').title()
            regime_font_color = '#00ff88' if 'UP' in last_regime_raw else (
                '#ff4444' if 'DOWN' in last_regime_raw else '#f0e68c'
            )
            fig.add_annotation(
                text=f"Regime: {latest_regime}",
                xref='paper',
                yref='paper',
                x=0.01,
                y=0.98,
                bgcolor='rgba(0,0,0,0.5)',
                font={'color': regime_font_color, 'size': 12},
                showarrow=False
            )

    # Add timeframe alignment markers
    if features.get('alignment', False):
        alignment = calculate_timeframe_alignment(df)
        if alignment:
            bullish_idx = alignment['bullish']
            bearish_idx = alignment['bearish']

            if bullish_idx.any():
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'][bullish_idx],
                        y=df['close'][bullish_idx],
                        mode='markers',
                        marker=dict(
                            symbol='triangle-up',
                            color='#00ff88',
                            size=8,
                            line=dict(color='#0a0a0a', width=1)
                        ),
                        name='TF Alignment (Bullish)',
                        hovertemplate='Bullish alignment<br>%{x|%Y-%m-%d %H:%M}'
                    ),
                    row=1, col=1
                )

            if bearish_idx.any():
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'][bearish_idx],
                        y=df['close'][bearish_idx],
                        mode='markers',
                        marker=dict(
                            symbol='triangle-down',
                            color='#ff4444',
                            size=8,
                            line=dict(color='#0a0a0a', width=1)
                        ),
                        name='TF Alignment (Bearish)',
                        hovertemplate='Bearish alignment<br>%{x|%Y-%m-%d %H:%M}'
                    ),
                    row=1, col=1
                )

    # Add Volume
    colors = ['#00ff88' if close >= open else '#ff4444'
              for close, open in zip(df['close'], df['open'])]
    fig.add_trace(
        go.Bar(
            x=df['timestamp'],
            y=df['volume'],
            name='Volume',
            marker_color=colors,
            opacity=0.6,
            yaxis='y2'
        ),
        row=2, col=1
    )

    # Add Order Flow
    if show_order_flow:
        df['body'] = abs(df['close'] - df['open'])
        df['upper_wick'] = df['high'] - df[['open', 'close']].max(axis=1)
        df['lower_wick'] = df[['open', 'close']].min(axis=1) - df['low']

        buying_pressure = (df['close'] > df['open']).astype(int)
        selling_pressure = (df['upper_wick'] > df['body'] * 1.5).astype(int)
        order_flow = buying_pressure - selling_pressure

        fig.add_trace(
            go.Bar(
                x=df['timestamp'],
                y=order_flow,
                name='Order Flow',
                marker_color=[
                    'rgba(0, 255, 0, 0.7)' if x > 0 else 'rgba(255, 0, 0, 0.7)'
                    for x in order_flow
                ],
                yaxis='y4'
            ),
            row=3, col=1
        )
    else:
        fig.update_yaxes(visible=False, row=3, col=1)
        fig.update_xaxes(showticklabels=False, row=3, col=1)

    # Update layout
    fig.update_layout(
        title=dict(
            text=f'<b>{symbol} Price Chart - {timeframe.upper()} Timeframe</b>',
            x=0.5,
            font=dict(size=20, color='white')
        ),
        height=800,
        showlegend=True,
        template='plotly_dark',
        xaxis_rangeslider_visible=False,
        paper_bgcolor='#0a0a0a',
        plot_bgcolor='#0a0a0a',
        font=dict(color='#ddd', size=11),
        dragmode='zoom',
        hovermode='x unified',
        hoverdistance=50,
        spikedistance=1000,
        uirevision=f"{symbol}-{timeframe}",
        legend=dict(
            bgcolor='rgba(0,0,0,0.5)',
            bordercolor='rgba(255,255,255,0.2)',
            borderwidth=1
        ),
        margin=dict(l=50, r=50, t=80, b=50)
    )

    # Update axes
    fig.update_yaxes(
        title_text="Price (USDT)",
        row=1,
        col=1,
        gridcolor='#333',
        automargin=True,
        side='right',
        fixedrange=False,
        showspikes=True,
        spikemode='across',
        spikecolor='#00ff88',
        spikethickness=1
    )
    fig.update_yaxes(
        title_text="Volume",
        row=2,
        col=1,
        gridcolor='#333',
        automargin=True,
        fixedrange=False,
        showspikes=True,
        spikemode='across',
        spikecolor='#00ff88',
        spikethickness=1
    )
    fig.update_yaxes(
        title_text="Order Flow" if show_order_flow else "",
        row=3,
        col=1,
        gridcolor='#333',
        showticklabels=show_order_flow,
        automargin=True,
        fixedrange=False,
        showspikes=True,
        spikemode='across',
        spikecolor='#00ff88',
        spikethickness=1
    )
    fig.update_xaxes(
        title_text="Time",
        row=3,
        col=1,
        gridcolor='#333',
        showticklabels=show_order_flow,
        showspikes=True,
        spikemode='across',
        spikecolor='#00ff88',
        spikethickness=1
    )

    # Add range selector with buttons for different time periods
    fig.update_xaxes(
        rangeslider=dict(
            visible=True,
            thickness=0.05,
            bgcolor='rgba(255, 255, 255, 0.05)',
            bordercolor='rgba(255, 255, 255, 0.1)',
            borderwidth=1
        ),
        rangeselector=dict(
            buttons=list([
                dict(count=50, label="50", step="all", stepmode="backward"),
                dict(count=100, label="100", step="all", stepmode="backward"),
                dict(count=200, label="200", step="all", stepmode="backward"),
                dict(step="all", label="All")
            ]),
            bgcolor='rgba(26, 26, 26, 0.9)',
            bordercolor='rgba(255, 255, 255, 0.2)',
            borderwidth=1,
            font=dict(color='#ddd', size=11)
        )
    )

    # Add signal annotations (LONG/SHORT markers based on order flow)
    if show_order_flow:
        # Generate sample trading signals based on order flow
        order_flow_threshold = 0.3
        long_signals = []
        short_signals = []

        for i in range(10, len(df) - 10):
            # Look for strong buying pressure followed by confirmation
            if i < len(order_flow):
                # LONG signal: positive order flow with price confirmation
                if (order_flow.iloc[i] > order_flow_threshold and
                    df['close'].iloc[i] > df['close'].iloc[i-5]):
                    long_signals.append({
                        'index': i,
                        'timestamp': df['timestamp'].iloc[i],
                        'price': df['high'].iloc[i] * 1.01,
                        'text': 'LONG'
                    })

                # SHORT signal: negative order flow with price confirmation
                elif (order_flow.iloc[i] < -order_flow_threshold and
                      df['close'].iloc[i] < df['close'].iloc[i-5]):
                    short_signals.append({
                        'index': i,
                        'timestamp': df['timestamp'].iloc[i],
                        'price': df['low'].iloc[i] * 0.99,
                        'text': 'SHORT'
                    })

        # Add LONG signal annotations
        for signal in long_signals[-5:]:  # Show last 5 signals
            fig.add_annotation(
                x=signal['timestamp'],
                y=signal['price'],
                text="<b>LONG</b>",
                showarrow=True,
                arrowhead=2,
                arrowcolor='#00ff88',
                arrowwidth=2,
                arrowsize=1,
                ax=0,
                ay=-40,
                bgcolor='rgba(0, 255, 136, 0.9)',
                bordercolor='#00ff88',
                borderwidth=1,
                borderpad=4,
                font=dict(color='#000', size=10, family='Arial Black')
            )

        # Add SHORT signal annotations
        for signal in short_signals[-5:]:  # Show last 5 signals
            fig.add_annotation(
                x=signal['timestamp'],
                y=signal['price'],
                text="<b>SHORT</b>",
                showarrow=True,
                arrowhead=2,
                arrowcolor='#ff4444',
                arrowwidth=2,
                arrowsize=1,
                ax=0,
                ay=40,
                bgcolor='rgba(255, 68, 68, 0.9)',
                bordercolor='#ff4444',
                borderwidth=1,
                borderpad=4,
                font=dict(color='#fff', size=10, family='Arial Black')
            )

    return fig


def create_positions_table(active_positions: Dict[str, Any]) -> html.Table:
    """Create HTML table for active positions."""
    if not active_positions:
        return html.Div("No active positions", style={'color': '#888', 'padding': '20px', 'textAlign': 'center'})

    # Table styles
    table_style = {
        'width': '100%',
        'borderCollapse': 'collapse',
        'marginTop': '20px',
        'fontSize': '14px'
    }

    header_style = {
        'backgroundColor': '#1a1a1a',
        'color': '#00ff88',
        'padding': '12px',
        'textAlign': 'left',
        'borderBottom': '2px solid #00ff88'
    }

    cell_style = {
        'padding': '10px 12px',
        'borderBottom': '1px solid #333',
        'color': '#ddd'
    }

    # Create table header
    header = html.Tr([
        html.Th("Symbol", style=header_style),
        html.Th("Side", style=header_style),
        html.Th("Entry Price", style=header_style),
        html.Th("Current Price", style=header_style),
        html.Th("Size", style=header_style),
        html.Th("P&L", style=header_style),
        html.Th("P&L %", style=header_style),
        html.Th("Actions", style=header_style)
    ])

    # Create table rows
    rows = []
    for symbol, position in active_positions.items():
        pnl = position.get('unrealized_pnl', 0)
        pnl_percent = position.get('unrealized_pnl_percent', 0)

        pnl_color = '#00ff88' if pnl >= 0 else '#ff4444'

        row_style = {
            'backgroundColor': '#1a1a1a' if len(rows) % 2 == 0 else '#0f0f0f'
        }

        rows.append(html.Tr([
            html.Td(symbol, style={**cell_style, **row_style}),
            html.Td(position.get('side', 'N/A'), style={**cell_style, **row_style}),
            html.Td(f"${position.get('entry_price', 0):.2f}", style={**cell_style, **row_style}),
            html.Td(f"${position.get('current_price', 0):.2f}", style={**cell_style, **row_style}),
            html.Td(f"{position.get('quantity', 0):.4f}", style={**cell_style, **row_style}),
            html.Td(f"${pnl:.2f}", style={**cell_style, 'color': pnl_color, **row_style}),
            html.Td(f"{pnl_percent:.2f}%", style={**cell_style, 'color': pnl_color, **row_style}),
            html.Td(
                html.Button('Close', id=f'close-{symbol}', n_clicks=0, style={
                    'backgroundColor': '#ff4444',
                    'color': 'white',
                    'border': 'none',
                    'padding': '6px 12px',
                    'cursor': 'pointer',
                    'borderRadius': '4px',
                    'fontSize': '12px'
                }),
                style={**cell_style, **row_style}
            )
        ]))

    return html.Table([header] + rows, style=table_style)


def create_metrics_card(title: str, value: str, subtitle: str = "", color: str = "#00ff88") -> html.Div:
    """Create a metrics card."""
    return html.Div([
        html.H4(title, style={'margin': '0', 'color': '#888', 'fontSize': '14px', 'fontWeight': 'normal'}),
        html.H2(value, style={'margin': '5px 0', 'color': color, 'fontSize': '28px', 'fontWeight': 'bold'}),
        html.P(subtitle, style={'margin': '0', 'color': '#666', 'fontSize': '11px'})
    ], style={
        'backgroundColor': '#1a1a1a',
        'padding': '15px',
        'borderRadius': '8px',
        'border': f'2px solid {color}',
        'minHeight': '80px',
        'display': 'flex',
        'flexDirection': 'column',
        'justifyContent': 'center'
    })


def layout():
    """Main dashboard layout with accessibility features."""
    return html.Div([
        # W2.4: Skip Link for Accessibility
        html.A(
            "Skip to main content",
            href='#main-content',
            className='skip-link',
            id='skip-link'
        ),

        # W2.4: ARIA Live Region for Announcements
        html.Div(id='aria-live-region', className='sr-only', **{'aria-live': 'polite', 'aria-atomic': 'true'}),

        # Header
        html.Div([
            html.Div([
                html.H1("DeepSeek Trading Dashboard", className='text-success mb-md'),
                html.P("Professional Trading Interface with Real-time Analysis", className='text-tertiary font-medium')
            ], className='text-center mb-lg'),

            # Symbol & Price Info
            html.Div([
                # Symbol Selector
                html.Div([
                    html.Label("Symbol:", className='text-tertiary mr-sm'),
                    dcc.Dropdown(
                        id='symbol-dropdown',
                        options=[
                            {'label': 'BTC/USDT', 'value': 'BTCUSDT'},
                            {'label': 'ETH/USDT', 'value': 'ETHUSDT'},
                            {'label': 'SOL/USDT', 'value': 'SOLUSDT'}
                        ],
                        value='BTCUSDT',
                        className='mb-0',
                        clearable=False,
                        placeholder='Select trading symbol',
                        **{'aria-label': 'Select trading symbol', 'role': 'combobox'}  # W2.4: ARIA attributes
                    )
                ], className='d-inline-block mr-lg'),

                # Live Price
                html.Div([
                    html.Label("Price:", className='text-tertiary mr-sm'),
                    html.Span("$0.00", id='live-price', className='text-success font-bold font-size-3xl', **{'aria-label': 'Current price', 'role': 'status'}),  # W2.4: ARIA
                    html.Span(" USDT", className='text-tertiary font-size-lg ml-xs')
                ], className='d-inline-block mr-lg'),

                # 24h Change
                html.Div([
                    html.Label("24h:", className='text-tertiary mr-sm'),
                    html.Span("+0.00%", id='price-change', className='text-tertiary font-semibold font-size-xl', **{'aria-label': '24 hour price change', 'role': 'status'})  # W2.4: ARIA
                ], className='d-inline-block'),

            ], className='text-center mt-md')
        ], className='ds-card shadow-md dashboard-header', **{'role': 'banner'})  # W2.4: ARIA role

        # Control Panel - Timeframe Selection
        html.Div([
            html.Div([
                html.Button('1m', id='tf-1m', n_clicks=0, className='mr-xs btn tooltip-top', **{  # W2.4: Tooltip and ARIA
                    'data-tooltip': 'Switch to 1 minute timeframe (Ctrl+1)',
                    'aria-label': 'Switch to 1 minute timeframe. Keyboard: Ctrl+1'
                }),
                html.Button('5m', id='tf-5m', n_clicks=0, className='mr-xs btn tooltip-top', **{  # W2.4: Tooltip and ARIA
                    'data-tooltip': 'Switch to 5 minute timeframe (Ctrl+2)',
                    'aria-label': 'Switch to 5 minute timeframe. Keyboard: Ctrl+2'
                }),
                html.Button('15m', id='tf-15m', n_clicks=0, className='mr-xs btn tooltip-top', **{  # W2.4: Tooltip and ARIA
                    'data-tooltip': 'Switch to 15 minute timeframe (Ctrl+3)',
                    'aria-label': 'Switch to 15 minute timeframe. Keyboard: Ctrl+3'
                }),
                html.Button('1h', id='tf-1h', n_clicks=0, className='mr-xs btn tooltip-top', **{  # W2.4: Tooltip and ARIA
                    'data-tooltip': 'Switch to 1 hour timeframe (Ctrl+4)',
                    'aria-label': 'Switch to 1 hour timeframe. Keyboard: Ctrl+4'
                }),
                html.Button('4h', id='tf-4h', n_clicks=0, className='mr-xs btn tooltip-top', **{  # W2.4: Tooltip and ARIA
                    'data-tooltip': 'Switch to 4 hour timeframe (Ctrl+5)',
                    'aria-label': 'Switch to 4 hour timeframe. Keyboard: Ctrl+5'
                }),
                html.Button('1d', id='tf-1d', n_clicks=0, className='mr-xs btn tooltip-top', **{  # W2.4: Tooltip and ARIA
                    'data-tooltip': 'Switch to 1 day timeframe (Ctrl+6)',
                    'aria-label': 'Switch to 1 day timeframe. Keyboard: Ctrl+6'
                })
            ], className='d-flex justify-center flex-wrap', **{'role': 'group', 'aria-label': 'Timeframe selection controls'})  # W2.4: ARIA group
        ], className='ds-card shadow-sm mb-lg dashboard-controls', **{'role': 'region', 'aria-label': 'Timeframe controls'})  # W2.4: ARIA region

        # Backtest Panel
        html.Div([
            html.H4("Backtest Runner", className='text-info mb-md'),
            html.Div([
                # Backtest Controls Row 1
                html.Div([
                    # Symbol
                    html.Div([
                        html.Label("Symbol", className='text-tertiary mr-sm'),
                        dcc.Dropdown(
                            id='backtest-symbol',
                            options=[
                                {'label': 'BTC/USDT', 'value': 'BTCUSDT'},
                                {'label': 'ETH/USDT', 'value': 'ETHUSDT'},
                                {'label': 'SOL/USDT', 'value': 'SOLUSDT'}
                            ],
                            value='BTCUSDT',
                            className='mb-0',
                            clearable=False
                        )
                    ], className='d-inline-block mr-md'),

                    # Timeframe
                    html.Div([
                        html.Label("Timeframe", className='text-tertiary mr-sm'),
                        dcc.Dropdown(
                            id='backtest-timeframe',
                            options=[
                                {'label': '1m', 'value': '1m'},
                                {'label': '5m', 'value': '5m'},
                                {'label': '15m', 'value': '15m'},
                                {'label': '1h', 'value': '1h'},
                                {'label': '4h', 'value': '4h'},
                                {'label': '1d', 'value': '1d'}
                            ],
                            value='1h',
                            className='mb-0',
                            clearable=False
                        )
                    ], className='d-inline-block mr-md'),

                    # Strategy
                    html.Div([
                        html.Label("Strategy", className='text-tertiary mr-sm'),
                        dcc.Dropdown(
                            id='backtest-strategy',
                            options=[
                                {'label': 'SMA', 'value': 'sma'},
                                {'label': 'RSI', 'value': 'rsi'},
                                {'label': 'MACD', 'value': 'macd'},
                                {'label': 'Convergence', 'value': 'convergence'}
                            ],
                            value='sma',
                            className='mb-0',
                            clearable=False
                        )
                    ], className='d-inline-block mr-md'),

                    # Run Button
                    html.Button('Run Backtest', id='run-backtest-btn', n_clicks=0, className='btn btn-primary mt-md')
                ], className='mb-md'),

                # Backtest Controls Row 2
                html.Div([
                    # Start Date
                    html.Div([
                        html.Label("Start", className='text-tertiary mr-sm'),
                        dcc.DatePickerSingle(
                            id='backtest-start-date',
                            date='2024-01-01',
                            display_format='YYYY-MM-DD'
                        )
                    ], className='d-inline-block mr-md'),

                    # End Date
                    html.Div([
                        html.Label("End", className='text-tertiary mr-sm'),
                        dcc.DatePickerSingle(
                            id='backtest-end-date',
                            date='2024-02-01',
                            display_format='YYYY-MM-DD'
                        )
                    ], className='d-inline-block mr-md'),

                    # Capital
                    html.Div([
                        html.Label("Capital", className='text-tertiary mr-sm'),
                        dcc.Input(
                            id='backtest-capital',
                            type='text',
                            value='10000',
                            className='p-xs'
                        )
                    ], className='d-inline-block mr-md'),

                    # Status
                    html.Div(id='backtest-status', className='text-tertiary font-size-sm mt-xs')
                ])
            ])
        ], className='ds-card shadow-sm mb-lg'),

        # Feature Profiles & Overlays
        html.Div([
            html.H4("Feature Profiles & Overlays", className='text-tertiary mb-md'),

            # Feature Profiles
            html.Div([
                html.Label("Strategy Mode:", className='text-tertiary font-size-sm mb-sm d-block'),
                html.Div([
                    html.Button('SCALP Scalp Mode', id='profile-scalp-btn', n_clicks=0, className='btn btn-success mr-sm'),
                    html.Button('SWING Swing Mode', id='profile-swing-btn', n_clicks=0, className='btn btn-outline mr-sm'),
                    html.Button('SCALP Custom', id='profile-custom-btn', n_clicks=0, className='btn btn-outline')
                ], className='mb-md pb-md')
            ], className='ds-panel-body mb-lg'),

            # Manual Overlay Toggles
            html.Div([
                html.Label("Manual Overrides (Optional):", className='text-tertiary font-size-sm mb-sm d-block'),
                dcc.Checklist(
                    id='feature-toggles',
                    options=[
                        {'label': 'Liquidity Zones', 'value': 'liquidity'},
                        {'label': 'Supertrend', 'value': 'supertrend'},
                        {'label': 'Chandelier Exit', 'value': 'chandelier'},
                        {'label': 'Order Flow', 'value': 'orderflow'},
                        {'label': 'Market Regime', 'value': 'regime'},
                        {'label': 'Alignment', 'value': 'alignment'}
                    ],
                    value=['liquidity', 'supertrend', 'chandelier', 'orderflow', 'regime'],  # Auto-enabled overlays
                    className='d-flex flex-wrap gap-md font-size-base',
                    labelClassName='p-sm border border-secondary rounded-sm',
                    inputClassName='mr-xs'
                )
            ], className='mb-sm'),
            html.P("Toggle chart overlays to show/hide trading features", className='text-tertiary font-size-xs text-center font-italic mb-0'),
            html.Div([
                html.Button('REFRESH Reset Overlays', id='reset-overlays-btn', n_clicks=0, className='btn btn-info mt-sm')
            ], className='text-center'),

            # System Controls
            html.Div([
                html.Button('START Start Trading', id='start-trading-btn', n_clicks=0, className='btn btn-success mr-sm'),
                html.Button('REFRESH Refresh Data', id='refresh-btn', n_clicks=0, className='btn btn-success mr-sm'),
                html.Button('Emergency Stop', id='emergency-stop-btn', n_clicks=0, className='btn btn-danger'),
                html.Div(id='trading-status-text', className='text-tertiary font-size-base text-center mt-md')
            ], className='text-center')
        ], className='ds-card shadow-sm mb-lg'),
        # Metrics Row
        html.Div([
            html.Div(id='metrics-cards', children=[
                create_metrics_card("Total P&L", "$0.00", "All time performance"),
                create_metrics_card("Win Rate", "0%", "Last 20 trades"),
                create_metrics_card("Active Positions", "0", "Currently open"),
                create_metrics_card("Current Drawdown", "0%", "Peak to trough")
            ], className='metrics-grid mb-lg')
        ]),

        # Feature Telemetry
        html.Div([
            html.H3("Feature Performance Telemetry", className='text-success mb-sm'),
            html.Div(
                id='feature-metrics',
                className='ds-card p-lg border border-primary',
                style={'minHeight': '90px'}
            )
        ], className='mb-lg'),

        # Convergence Strategy Panel
        html.Div([
            html.H3("Multi-Timeframe Convergence Strategy", className='text-warning mb-md'),
            html.Div([
                # Strategy Status
                html.Div([
                    html.Div("Strategy Status", className='text-tertiary font-size-sm mb-xs'),
                    html.Div(id='convergence-status', children="Ready", className='text-success font-semibold font-size-lg')
                ], className='flex-1 mr-lg'),

                # Action
                html.Div([
                    html.Div("Current Action", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='convergence-action', children="HOLD", style={
                        'color': '#888',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                # Confidence
                html.Div([
                    html.Div("Confidence", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='convergence-confidence', children="0%", style={
                        'color': '#888',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                # Alignment Score
                html.Div([
                    html.Div("Alignment Score", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='convergence-alignment-score', children="0.0", style={
                        'color': '#888',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                # Market Regime
                html.Div([
                    html.Div("Market Regime", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='convergence-regime', children="N/A", style={
                        'color': '#888',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'})
            ], style={'display': 'flex', 'flexWrap': 'wrap', 'marginBottom': '15px'}),

            # Entry/Exit Levels
            html.Div([
                html.Div([
                    html.Div("Entry Price", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='convergence-entry-price', children="$0.00", style={
                        'color': '#fff',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Stop Loss", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='convergence-stop-loss', children="$0.00", style={
                        'color': '#ff4444',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Take Profit", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='convergence-take-profit', children="$0.00", style={
                        'color': '#00ff88',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Risk:Reward", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='convergence-risk-reward', children="0:0", style={
                        'color': '#fff',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'})
            ], style={'display': 'flex', 'flexWrap': 'wrap', 'marginBottom': '15px'}),

            # Satisfied Conditions
            html.Div([
                html.Div("Satisfied Conditions (4 of 6 required)", style={
                    'color': '#888',
                    'fontSize': '12px',
                    'marginBottom': '8px'
                }),
                html.Div(
                    id='convergence-conditions',
                    children=[
                        html.Span("No signals", style={'color': '#666', 'fontStyle': 'italic'})
                    ],
                    style={
                        'backgroundColor': '#0a0a0a',
                        'padding': '12px',
                        'borderRadius': '6px',
                        'border': '1px solid #333',
                        'minHeight': '40px'
                    }
                )
            ], style={'marginBottom': '15px'}),

            # Reasoning
            html.Div([
                html.Div("Reasoning", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '8px'}),
                html.Div(
                    id='convergence-reasoning',
                    children="Run convergence strategy to analyze multi-timeframe alignment",
                    style={
                        'backgroundColor': '#0a0a0a',
                        'padding': '12px',
                        'borderRadius': '6px',
                        'border': '1px solid #333',
                        'minHeight': '40px',
                        'color': '#ccc',
                        'fontSize': '13px',
                        'fontFamily': 'monospace'
                    }
                )
            ], style={'marginBottom': '15px'}),

            # Control Buttons
            html.Div([
                html.Button('CONVERGENCE Run Convergence Strategy', id='convergence-run-btn', n_clicks=0, style={
                    'backgroundColor': '#ff9900',
                    'color': 'black',
                    'border': 'none',
                    'padding': '10px 25px',
                    'cursor': 'pointer',
                    'borderRadius': '5px',
                    'fontSize': '14px',
                    'fontWeight': 'bold',
                    'marginRight': '10px'
                }),
                html.Button('REFRESH Refresh', id='refresh-convergence-btn', n_clicks=0, style={
                    'backgroundColor': '#4488ff',
                    'color': 'white',
                    'border': 'none',
                    'padding': '10px 25px',
                    'cursor': 'pointer',
                    'borderRadius': '5px',
                    'fontSize': '14px',
                    'fontWeight': 'bold',
                    'marginRight': '10px'
                })
            ], style={'textAlign': 'left'})
        ], style={
            'backgroundColor': '#1a1a1a',
            'padding': '20px',
            'borderRadius': '8px',
            'border': '2px solid #ff9900',
            'marginBottom': '20px'
        }, className='dashboard-strategies'),

        # Scalp Strategy Panel
        html.Div([
            html.H3("15m Scalp with 4h Awareness Strategy", style={'color': '#4488ff', 'marginBottom': '15px', 'fontSize': '18px'}),
            html.Div([
                # Strategy Status
                html.Div([
                    html.Div("Strategy Status", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-status', children="Ready", style={
                        'color': '#00ff88',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                # Action
                html.Div([
                    html.Div("Current Action", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-action', children="WAIT", style={
                        'color': '#888',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                # Confidence
                html.Div([
                    html.Div("Confidence", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-confidence', children="0%", style={
                        'color': '#888',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                # Entry Type
                html.Div([
                    html.Div("Entry Type", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-entry-type', children="N/A", style={
                        'color': '#fff',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'})
            ], style={'display': 'flex', 'flexWrap': 'wrap', 'marginBottom': '15px'}),

            # Entry/Exit Levels
            html.Div([
                html.Div([
                    html.Div("Entry Price", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-entry-price', children="$0.00", style={
                        'color': '#fff',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Stop Loss", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-stop-loss', children="$0.00", style={
                        'color': '#ff4444',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Take Profit 1", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-take-profit-1', children="$0.00", style={
                        'color': '#00ff88',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Take Profit 2", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-take-profit-2', children="$0.00", style={
                        'color': '#00ff88',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'})
            ], style={'display': 'flex', 'flexWrap': 'wrap', 'marginBottom': '15px'}),

            # Entry Zone and Position Size
            html.Div([
                html.Div([
                    html.Div("Entry Zone / Trigger", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-entry-zone', children="N/A", style={
                        'color': '#fff',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Position Size", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                    html.Div(id='scalp-position-size', children="0%", style={
                        'color': '#00ff88',
                        'fontSize': '14px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'})
            ], style={'display': 'flex', 'flexWrap': 'wrap', 'marginBottom': '15px'}),

            # Reasoning
            html.Div([
                html.Div("Reasoning", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '8px'}),
                html.Div(
                    id='scalp-reasoning',
                    children="Run scalp strategy to analyze 15m setup with 4h context",
                    style={
                        'backgroundColor': '#0a0a0a',
                        'padding': '12px',
                        'borderRadius': '6px',
                        'border': '1px solid #333',
                        'minHeight': '40px',
                        'color': '#ccc',
                        'fontSize': '13px',
                        'fontFamily': 'monospace'
                    }
                )
            ], style={'marginBottom': '15px'}),

            # Alert Status
            html.Div([
                html.Div("Alert Status", style={'color': '#888', 'fontSize': '12px', 'marginBottom': '5px'}),
                html.Div(id='scalp-alert-status', children="No Active Alerts", style={
                    'color': '#888',
                    'fontSize': '14px',
                    'fontWeight': 'bold'
                })
            ], style={'marginBottom': '15px'}),

            # Control Buttons
            html.Div([
                html.Button('SCALP Run Scalp Strategy', id='scalp-run-btn', n_clicks=0, style={
                    'backgroundColor': '#4488ff',
                    'color': 'white',
                    'border': 'none',
                    'padding': '10px 25px',
                    'cursor': 'pointer',
                    'borderRadius': '5px',
                    'fontSize': '14px',
                    'fontWeight': 'bold',
                    'marginRight': '10px'
                }),
                html.Button('REFRESH Refresh', id='refresh-scalp-btn', n_clicks=0, style={
                    'backgroundColor': '#ff9900',
                    'color': 'black',
                    'border': 'none',
                    'padding': '10px 25px',
                    'cursor': 'pointer',
                    'borderRadius': '5px',
                    'fontSize': '14px',
                    'fontWeight': 'bold',
                    'marginRight': '10px'
                }),
                html.Button('ðŸ”” Setup Alerts', id='setup-alerts-btn', n_clicks=0, style={
                    'backgroundColor': '#00ff88',
                    'color': 'black',
                    'border': 'none',
                    'padding': '10px 25px',
                    'cursor': 'pointer',
                    'borderRadius': '5px',
                    'fontSize': '14px',
                    'fontWeight': 'bold',
                    'marginRight': '10px'
                }),
                html.Button('ðŸ—‘ï¸ Clear Alerts', id='clear-alerts-btn', n_clicks=0, style={
                    'backgroundColor': '#ff4444',
                    'color': 'white',
                    'border': 'none',
                    'padding': '10px 25px',
                    'cursor': 'pointer',
                    'borderRadius': '5px',
                    'fontSize': '14px',
                    'fontWeight': 'bold'
                })
            ], style={'textAlign': 'left'})
        ], style={
            'backgroundColor': '#1a1a1a',
            'padding': '20px',
            'borderRadius': '8px',
            'border': '2px solid #4488ff',
            'marginBottom': '20px'
        }, className='dashboard-strategies'),

        # Backtest Results Store
        dcc.Store(id='backtest-result-store'),

        # Backtest Results Modal
        html.Div([
            dbc.Modal([
                dbc.ModalHeader(dbc.ModalTitle("Backtest Results", id='backtest-modal-title')),
                dbc.ModalBody(id='backtest-modal-body'),
                dbc.ModalFooter([
                    html.Div(id='promote-backtest-output'),
                    dbc.Button("Promote to Production", id='promote-backtest-btn', color='success', style={'marginRight': '10px'}),
                    dbc.Button("Close", id='backtest-modal-close', color='secondary')
                ])
            ], id='backtest-modal', is_open=False, size='lg')
        ]),

        # Main Chart
        html.Div([
            # Skeleton loader (shown initially)
            html.Div(
                id='chart-skeleton',
                children=[
                    html.Div(className='skeleton', style={'height': '800px', 'width': '100%', 'borderRadius': '8px'}),
                    html.Div(className='skeleton-title', style={
                        'height': '24px',
                        'width': '60%',
                        'marginBottom': '10px',
                        'backgroundColor': 'var(--color-bg-secondary)',
                        'borderRadius': '4px'
                    })
                ],
                className='lazy-load-skeleton',
                style={'display': 'block'}
            ),
            dcc.Graph(
                id='price-chart',
                config={
                    'displayModeBar': True,
                    'displaylogo': False,
                    'scrollZoom': True,
                    'doubleClick': 'reset',
                    'modeBarButtonsToRemove': ['lasso2d', 'select2d'],
                    'modeBarButtonsToAdd': ['zoom2d', 'pan2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d'],
                    'toImageButtonOptions': {
                        'format': 'png',
                        'filename': 'trading_chart',
                        'height': 800,
                        'width': 1600,
                        'scale': 1
                    }
                },
                style={'display': 'none'},  # Initially hidden, shown after load
                loading_state={
                    'is_loading': True,
                    'component_name': 'price-chart'
                }
            )
        ],
        style={'marginBottom': '20px'},
        className='dashboard-chart',
        **{'data-lazy-load': 'true', 'data-component': 'price-chart'}  # W2.3: Lazy loading attributes
        ),

        # Chat Interface
        html.Div([
            html.H3("DeepSeek AI Chat", style={'color': '#00ff88', 'marginBottom': '15px', 'fontSize': '18px'}),

            # Quick Actions
            html.Div([
                html.Div(id='chat-quick-actions', children=[
                    html.Button('ANALYZE Analyze Performance', id='chat-analyze-perf', n_clicks=0, style={
                        'backgroundColor': '#2a2a2a', 'color': 'white', 'border': '1px solid #444',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px'
                    }),
                    html.Button('CONVERGENCE Market Analysis', id='chat-market-analysis', n_clicks=0, style={
                        'backgroundColor': '#2a2a2a', 'color': 'white', 'border': '1px solid #444',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px'
                    }),
                    html.Button('âš ï¸ Risk Assessment', id='chat-risk-assessment', n_clicks=0, style={
                        'backgroundColor': '#2a2a2a', 'color': 'white', 'border': '1px solid #444',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px'
                    }),
                    html.Button('OPTIMIZE System Optimization', id='chat-system-opt', n_clicks=0, style={
                        'backgroundColor': '#2a2a2a', 'color': 'white', 'border': '1px solid #444',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px'
                    }),
                    html.Button('SWING Feature Performance', id='chat-feature-perf', n_clicks=0, style={
                        'backgroundColor': '#2a2a2a', 'color': 'white', 'border': '1px solid #444',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px'
                    }),
                    html.Button('CLOSE Close All Positions', id='chat-close-positions', n_clicks=0, style={
                        'backgroundColor': '#2a2a2a', 'color': 'white', 'border': '1px solid #444',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px'
                    }),
                    html.Button('â¸ï¸ Pause Trading', id='chat-pause-trading', n_clicks=0, style={
                        'backgroundColor': '#2a2a2a', 'color': 'white', 'border': '1px solid #444',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px'
                    }),
                    html.Button('â–¶ï¸ Resume Trading', id='chat-resume-trading', n_clicks=0, style={
                        'backgroundColor': '#2a2a2a', 'color': 'white', 'border': '1px solid #444',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px'
                    }),
                    html.Button('CONVERGENCE Convergence Strategy', id='chat-convergence-btn', n_clicks=0, style={
                        'backgroundColor': '#ff9900', 'color': 'black', 'border': '1px solid #ff9900',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px', 'fontWeight': 'bold'
                    }),
                    html.Button('SCALP Scalp Strategy', id='chat-scalp-btn', n_clicks=0, style={
                        'backgroundColor': '#4488ff', 'color': 'white', 'border': '1px solid #4488ff',
                        'padding': '8px 12px', 'margin': '5px', 'cursor': 'pointer', 'borderRadius': '5px', 'fontSize': '13px', 'fontWeight': 'bold'
                    })
                ], style={'display': 'flex', 'flexWrap': 'wrap'})
            ], style={'marginBottom': '15px'}),

            # Chat History
            dcc.Loading(
                id='chat-loading',
                type='default',
                color='#00ff88',
                children=html.Div(
                    id='chat-history',
                    children=[
                        # Welcome message
                        html.Div([
                            html.Div("DeepSeek AI", style={'fontWeight': 'bold', 'marginBottom': '5px', 'color': '#4488ff'}),
                            html.Div('Hello! I am DeepSeek, your AI trading assistant. I can help you analyze markets, review performance, assess risks, and optimize your trading system. How can I help you today?', style={
                                'backgroundColor': '#1a1a1a', 'padding': '15px', 'borderRadius': '8px',
                                'maxWidth': '70%', 'borderLeft': '3px solid #4488ff'
                            }),
                            html.Div(datetime.now().strftime('%H:%M:%S'), style={'fontSize': '10px', 'color': '#666', 'marginTop': '5px'})
                        ], style={'marginBottom': '15px'})
                    ],
                    style={
                        'height': '300px',
                        'overflowY': 'scroll',
                        'padding': '20px',
                        'backgroundColor': '#0a0a0a',
                        'borderRadius': '8px',
                        'border': '1px solid #333',
                        'marginBottom': '15px'
                    }
                )
            ),

            # Chat Input
            html.Div([
                dcc.Textarea(
                    id='chat-input',
                    placeholder='Type your message to DeepSeek...',
                    style={
                        'width': '100%',
                        'height': '60px',
                        'backgroundColor': '#1a1a1a',
                        'color': 'white',
                        'border': '1px solid #444',
                        'borderRadius': '5px',
                        'padding': '10px',
                        'fontSize': '14px',
                        'resize': 'vertical'
                    }
                ),
                html.Div([
                    html.Button('Send Message', id='chat-send-button', n_clicks=0, disabled=True, style={
                        'backgroundColor': '#00ff88', 'color': 'black', 'border': 'none',
                        'padding': '8px 20px', 'cursor': 'pointer', 'borderRadius': '5px',
                        'fontSize': '14px', 'fontWeight': 'bold', 'marginTop': '8px'
                    }),
                    html.Button('Clear Chat', id='chat-clear-button', n_clicks=0, style={
                        'backgroundColor': '#444', 'color': 'white', 'border': 'none',
                        'padding': '8px 20px', 'cursor': 'pointer', 'borderRadius': '5px',
                        'fontSize': '14px', 'marginLeft': '10px', 'marginTop': '8px'
                    }),
                    html.Span('Chat history saved to: logs/chat_history.log', id='chat-status', style={
                        'color': '#888', 'fontSize': '11px', 'marginLeft': '20px', 'marginTop': '12px', 'display': 'inline-block'
                    })
                ], style={'textAlign': 'left'})
            ], style={'backgroundColor': '#1a1a1a', 'padding': '15px', 'borderRadius': '8px'})

        ],
        style={'padding': '20px', 'backgroundColor': '#1a1a1a', 'borderRadius': '8px', 'marginBottom': '20px'},
        className='dashboard-chat',
        **{'data-lazy-load': 'true', 'data-component': 'chat-interface'}  # W2.3: Lazy loading attributes
        ),

        # Positions Table
        html.Div([
            html.H3("Active Positions", style={'color': '#00ff88', 'marginBottom': '15px', 'fontSize': '18px'}),
            html.Div(id='positions-table')
        ], style={'padding': '20px', 'backgroundColor': '#1a1a1a', 'borderRadius': '8px', 'marginBottom': '20px'}, className='dashboard-positions'),

        # System Health
        html.Div([
            html.H3("System Health & Performance", style={'color': '#00ff88', 'marginBottom': '15px', 'fontSize': '18px'}),
            html.Div(id='system-health', children=[
                html.P("Loading...", style={'color': '#ddd', 'margin': '5px 0', 'fontSize': '13px'})
            ])
        ], style={'padding': '20px', 'backgroundColor': '#1a1a1a', 'borderRadius': '8px'}, className='dashboard-system'),

        # Performance Metrics Monitor
        html.Div([
            html.Div("Performance Metrics", style={
                'fontWeight': 'bold',
                'marginBottom': '8px',
                'fontSize': '11px',
                'color': '#888'
            }),
            html.Div(id='performance-metrics-display', children=[
                html.Div([
                    html.Span("FPS:", className='performance-metric-label'),
                    html.Span("60", id='perf-fps', className='performance-metric-value')
                ], className='performance-metric'),
                html.Div([
                    html.Span("Memory:", className='performance-metric-label'),
                    html.Span("0 MB", id='perf-memory', className='performance-metric-value')
                ], className='performance-metric'),
                html.Div([
                    html.Span("Render:", className='performance-metric-label'),
                    html.Span("0ms", id='perf-render', className='performance-metric-value')
                ], className='performance-metric'),
                html.Div([
                    html.Span("Cache Hit:", className='performance-metric-label'),
                    html.Span("--", id='perf-cache', className='performance-metric-value')
                ], className='performance-metric'),
            ])
        ], id='performance-metrics', className='performance-metrics', style={
            'display': 'none'  # Hidden by default, shown via callback
        }),

        # Lightweight refresh loop keeps prices/live stats in sync
        dcc.Interval(
            id='interval-component',
            interval=2000,  # 2 seconds for snappier updates
            n_intervals=0
        ),

        # Stores for callbacks
        dcc.Store(id='market-data-store'),
        dcc.Store(id='positions-store'),
        dcc.Store(id='trade-history-store'),
        dcc.Store(id='timeframe-store', data='15m'),
        dcc.Store(id='chat-store', data=[]),
        dcc.Store(id='chart-view-store', data={}),
        dcc.Store(id='trading-status-store')

    ],
    id='main-content',  # W2.4: Main content ID for skip link
    className='dashboard-layout',
    **{'role': 'main', 'aria-label': 'Trading Dashboard Main Content'}  # W2.4: ARIA role
    , style={
        'backgroundColor': '#0a0a0a',
        'minHeight': '100vh',
        'padding': '0px',
        'color': 'white',
        'fontFamily': 'Arial, sans-serif'
    })


# Enable/disable chat send button based on input
@callback(
    Output('chat-send-button', 'disabled'),
    Input('chat-input', 'value')
)
def toggle_chat_send_button(input_text):
    """Disable send button when message box is empty."""
    if input_text and input_text.strip():
        return False
    return True


# Callbacks for timeframe selection
@callback(
    [Output('tf-1m', 'style'),
     Output('tf-5m', 'style'),
     Output('tf-15m', 'style'),
     Output('tf-1h', 'style'),
     Output('tf-4h', 'style'),
     Output('tf-1d', 'style'),
     Output('timeframe-store', 'data')],
    [Input('tf-1m', 'n_clicks'),
     Input('tf-5m', 'n_clicks'),
     Input('tf-15m', 'n_clicks'),
     Input('tf-1h', 'n_clicks'),
     Input('tf-4h', 'n_clicks'),
     Input('tf-1d', 'n_clicks')],
    [State('timeframe-store', 'data')]
)
def update_timeframe_selection(m1_clicks, m5_clicks, m15_clicks, h1_clicks, h4_clicks, d1_clicks, current_tf):
    """Update timeframe selection buttons and store."""
    ctx = callback_context

    base_style = {
        'backgroundColor': '#333',
        'color': 'white',
        'border': '1px solid #555',
        'padding': '10px 15px',
        'cursor': 'pointer',
        'borderRadius': '5px',
        'margin': '3px',
        'fontSize': '14px',
        'minWidth': '60px'
    }
    active_style = {
        'backgroundColor': '#00ff88',
        'color': 'black',
        'border': '1px solid #00ff88',
        'padding': '10px 15px',
        'cursor': 'pointer',
        'borderRadius': '5px',
        'margin': '3px',
        'fontSize': '14px',
        'minWidth': '60px',
        'fontWeight': 'bold'
    }

    # Highlight selected button
    timeframe_map = {
        'tf-1m': '1m',
        'tf-5m': '5m',
        'tf-15m': '15m',
        'tf-1h': '1h',
        'tf-4h': '4h',
        'tf-1d': '1d'
    }

    if not ctx.triggered:
        selected_tf = current_tf or '15m'
    else:
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]
        logger.info(f"[DIAGNOSTIC] Timeframe button clicked: {button_id}, Current TF in store: {current_tf}")
        selected_tf = timeframe_map.get(button_id, current_tf)
        logger.info(f"[DIAGNOSTIC] Selected timeframe: {selected_tf} - CHANGING FROM {current_tf}")

    styles = {}
    for btn_id, tf in timeframe_map.items():
        styles[btn_id] = active_style.copy() if tf == selected_tf else base_style.copy()

    # Update GLOBAL_STATE immediately for chat context
    GLOBAL_STATE['selected_timeframe'] = selected_tf
    logger.info(f"[DIAGNOSTIC] Updated GLOBAL_STATE['selected_timeframe'] to: {selected_tf}")

    # Return the updated styles and new timeframe
    # The chart will be updated by update_dashboard callback when timeframe-store changes
    return [
        styles['tf-1m'],
        styles['tf-5m'],
        styles['tf-15m'],
        styles['tf-1h'],
        styles['tf-4h'],
        styles['tf-1d'],
        selected_tf
    ]


# Feature toggles are handled directly in update_dashboard callback via feature-toggles input
# The dcc.Checklist component in the layout automatically updates the features store


# Global to track previous timeframe for cache clearing
LAST_TIMEFRAME = {'value': None}

# Main dashboard update callback
@callback(
    [Output('price-chart', 'figure'),
     Output('live-price', 'children'),
     Output('price-change', 'children'),
     Output('price-change', 'style'),
     Output('positions-table', 'children'),
     Output('metrics-cards', 'children'),
     Output('system-health', 'children'),
     Output('feature-metrics', 'children')],
    [Input('interval-component', 'n_intervals'),
     Input('refresh-btn', 'n_clicks'),
     Input('symbol-dropdown', 'value'),
     Input('timeframe-store', 'data'),
     Input('feature-toggles', 'value'),
     Input('force-refresh-btn', 'n_clicks')],
    [State('chart-view-store', 'data')]
)
def update_dashboard(n, n_clicks, symbol, timeframe, feature_toggles, force_refresh_clicks, chart_view_store):
    """Update dashboard with latest data."""
    start_time = time.perf_counter()

    # Check what triggered this callback
    ctx = callback_context
    trigger = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else 'unknown'

    if trigger == 'feature-toggles':
        now = time.time()
        if now - LAST_TOGGLE['ts'] < 10:
            logger.debug("Ignoring rapid overlay toggle to prevent thrash.")
            raise PreventUpdate
        LAST_TOGGLE['ts'] = now

    # P1.2: Handle force refresh button
    force_refresh = False
    if trigger == 'force-refresh-btn' and force_refresh_clicks > 0:
        logger.warning("Force Live Refresh button clicked - clearing DATA_CACHE")
        global DATA_CACHE
        DATA_CACHE.clear()
        force_refresh = True

    # Normalize feature toggles and update GLOBAL_STATE
    feature_toggles = feature_toggles or []
    GLOBAL_STATE['active_features'] = {
        'liquidity': 'liquidity' in feature_toggles,
        'supertrend': 'supertrend' in feature_toggles,
        'chandelier': 'chandelier' in feature_toggles,
        'orderflow': 'orderflow' in feature_toggles,
        'regime': 'regime' in feature_toggles,
        'alignment': 'alignment' in feature_toggles
    }
    GLOBAL_STATE['selected_symbol'] = symbol
    GLOBAL_STATE['selected_timeframe'] = timeframe

    update_overlay_context(GLOBAL_STATE['active_features'], timeframe)
    current_regime = CHAT_SYSTEM_CONTEXT.market_regime if CHAT_SYSTEM_CONTEXT else "UNKNOWN"
    GLOBAL_STATE['current_regime'] = current_regime
    recommended_overlays = REGIME_FEATURE_STRATEGY.get(current_regime, [])

    # Log timeframe changes
    if trigger in ['tf-1m', 'tf-5m', 'tf-15m', 'tf-1h', 'tf-4h', 'tf-1d']:
        logger.info(f"[DIAGNOSTIC] Timeframe changed in update_dashboard - Old: {GLOBAL_STATE.get('selected_timeframe')}, New: {timeframe}")
    GLOBAL_STATE['selected_timeframe'] = timeframe

    logger.info(
        f"[DIAGNOSTIC] TRIGGER: {trigger} | Symbol: {symbol}, Timeframe: {timeframe}, "
        f"Active Features: {GLOBAL_STATE['active_features']}"
    )

    # Force refresh if timeframe changed OR if button was clicked
    timeframe_changed = LAST_TIMEFRAME['value'] != timeframe
    if timeframe_changed:
        force_refresh = True
    LAST_TIMEFRAME['value'] = timeframe

    # Fetch market data (cached if timeframe/feature change, new data if interval/refresh)
    fetch_start = time.perf_counter()
    df, fetch_meta = fetch_market_data(symbol, timeframe, num_bars=1000, force_refresh=force_refresh)
    fetch_duration = (time.perf_counter() - fetch_start) * 1000
    logger.debug(
        "Data fetch duration: %.1f ms (used_sample_data=%s, cache_hit=%s, force_refresh=%s)",
        fetch_duration,
        fetch_meta['used_sample_data'],
        fetch_meta['cache_hit'],
        force_refresh
    )

    # Calculate current price and change
    current_price = df['close'].iloc[-1]
    price_24h = df['close'].iloc[-25] if len(df) > 25 else df['close'].iloc[0]
    price_change = ((current_price - price_24h) / price_24h) * 100
    price_change_str = f"+{price_change:.2f}%" if price_change >= 0 else f"{price_change:.2f}%"
    price_change_color = '#00ff88' if price_change >= 0 else '#ff4444'
    price_change_style = {'color': price_change_color, 'fontSize': '18px', 'fontWeight': 'bold'}

    # Create price chart
    chart_start = time.perf_counter()
    price_fig = create_interactive_chart(
        df,
        symbol,
        timeframe,
        GLOBAL_STATE['active_features']
    )
    view_key = f"{symbol}:{timeframe}"
    stored_view = (chart_view_store or {}).get(view_key, {})
    if stored_view:
        x_range = stored_view.get('x')
        y_range = stored_view.get('y')
        if x_range and len(x_range) == 2:
            price_fig.update_xaxes(range=x_range, row=1, col=1)
            price_fig.update_xaxes(range=x_range, row=2, col=1)
            price_fig.update_xaxes(range=x_range, row=3, col=1)
        if y_range and len(y_range) == 2:
            price_fig.update_yaxes(range=y_range, row=1, col=1)
    chart_duration = (time.perf_counter() - chart_start) * 1000
    total_duration = (time.perf_counter() - start_time) * 1000
    logger.debug(
        f"Chart build duration: {chart_duration:.1f} ms | Total callback duration: {total_duration:.1f} ms"
    )

    # Sample positions (empty in demo mode)
    sample_positions = {}

    # Sample metrics
    metrics = [
        create_metrics_card("Total P&L", "$0.00", "All time performance"),
        create_metrics_card("Win Rate", "0%", "Last 20 trades"),
        create_metrics_card("Active Positions", str(len(sample_positions)), "Currently open"),
        create_metrics_card("Current Drawdown", "0%", "Peak to trough")
    ]

    # System health
    import psutil
    memory_mb = psutil.Process().memory_info().rss / 1024 / 1024
    connection_label = "Live Binance" if not fetch_meta['used_sample_data'] else "Sample Data"

    # P1.2: Add data freshness information
    last_candle_str = "N/A"
    freshness_str = "Unknown"
    freshness_color = '#ddd'

    if df is not None and len(df) > 0:
        last_timestamp = pd.to_datetime(df['timestamp'].iloc[-1])
        last_candle_str = last_timestamp.strftime('%Y-%m-%d %H:%M:%S')

        # Calculate freshness
        last_candle_age_min = fetch_meta.get('last_candle_age_min', 0)
        is_stale = fetch_meta.get('is_stale', False)
        tf_minutes = fetch_meta.get('tf_minutes', 60)

        if last_candle_age_min > 0:
            freshness_str = f"Î”={last_candle_age_min:.1f}m"
            if is_stale:
                freshness_str += " (STALE)"
                freshness_color = '#ff4444'
            else:
                freshness_color = '#00ff88'

    system_health = [
        html.P(f"Memory Usage: {memory_mb:.0f} MB", style={'color': '#ddd', 'margin': '5px 0', 'fontSize': '13px'}),
        html.P(f"CPU Usage: {psutil.cpu_percent():.1f}%", style={'color': '#ddd', 'margin': '5px 0', 'fontSize': '13px'}),
        html.P(f"Last Update: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", style={'color': '#ddd', 'margin': '5px 0', 'fontSize': '13px'}),
        html.P(f"Data Connection: {connection_label}", style={'color': '#888', 'margin': '5px 0', 'fontSize': '13px'}),
        html.P(f"Last Candle: {last_candle_str}", id='last-candle-timestamp', style={'color': '#ddd', 'margin': '5px 0', 'fontSize': '13px'}),
        html.P(f"Data Freshness: {freshness_str}", id='data-freshness', style={'color': freshness_color, 'margin': '5px 0', 'fontSize': '13px', 'fontWeight': 'bold'}),
        html.Button(
            'REFRESH Force Live Refresh',
            id='force-refresh-btn',
            n_clicks=0,
            style={
                'backgroundColor': '#ff9900',
                'color': 'black',
                'border': 'none',
                'padding': '8px 16px',
                'borderRadius': '5px',
                'cursor': 'pointer',
                'fontSize': '13px',
                'fontWeight': 'bold',
                'marginTop': '10px'
            }
        )
    ]

    feature_metrics_data = CHAT_SYSTEM_CONTEXT.feature_resource_usage if CHAT_SYSTEM_CONTEXT else {}
    feature_metrics_component = create_feature_metrics_table(
        feature_metrics_data,
        current_regime=current_regime,
        recommendations=recommended_overlays
    )

    return (
        price_fig,
        f"${current_price:,.2f}",
        price_change_str,
        price_change_style,
        create_positions_table(sample_positions),
        metrics,
        system_health,
        feature_metrics_component
    )


# Convergence Strategy Callback
@callback(
    [Output('convergence-status', 'children'),
     Output('convergence-action', 'children'),
     Output('convergence-action', 'style'),
     Output('convergence-confidence', 'children'),
     Output('convergence-alignment-score', 'children'),
     Output('convergence-regime', 'children'),
     Output('convergence-entry-price', 'children'),
     Output('convergence-stop-loss', 'children'),
     Output('convergence-take-profit', 'children'),
     Output('convergence-risk-reward', 'children'),
     Output('convergence-conditions', 'children'),
     Output('convergence-reasoning', 'children')],
    [Input('convergence-run-btn', 'n_clicks'),
     Input('chat-convergence-btn', 'n_clicks'),
     Input('refresh-convergence-btn', 'n_clicks'),
     Input('interval-component', 'n_intervals')],
    [State('symbol-dropdown', 'value'),
     State('timeframe-store', 'data')]
)
def update_convergence_strategy(run_clicks, chat_run_clicks, refresh_clicks, n_intervals, symbol, timeframe):
    """Update convergence strategy panel with latest signal."""
    ctx = callback_context
    trigger = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else 'unknown'

    # Only run on button click or periodic refresh
    if trigger not in ['convergence-run-btn', 'chat-convergence-btn', 'refresh-convergence-btn', 'interval-component']:
        raise PreventUpdate

    try:
        # Import necessary modules
        from core.signal_generator import SignalGenerator
        from core.system_context import SystemContext
        from features.engine import FeatureEngine
        from core.data.binance_client import BinanceClient

        # Initialize components
        system_context = SystemContext()
        feature_engine = FeatureEngine()
        signal_generator = SignalGenerator(
            system_context=system_context,
            deepseek_brain=None,  # Not needed for signal generation
            feature_engine=feature_engine,
            enable_convergence_strategy=True
        )

        # Fetch market data for active timeframe
        df, fetch_meta = fetch_market_data(symbol, timeframe, num_bars=500, force_refresh=True)

        # Convert DataFrame to dict format expected by signal generator
        market_data = {
            'open': df['open'],
            'high': df['high'],
            'low': df['low'],
            'close': df['close'],
            'volume': df['volume']
        }

        # Fetch multi-timeframe data for convergence strategy
        timeframes = ['1m', '5m', '15m', '1h', '4h', '1d']
        multi_timeframe_data = {}

        try:
            # Try to use BinanceClient.get_multiple_timeframes
            import asyncio
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            try:
                binance_client = BinanceClient()
                multi_timeframe_df = loop.run_until_complete(
                    binance_client.get_multiple_timeframes(symbol, timeframes)
                )

                # Store DataFrames directly (signal generator expects DataFrames)
                for tf, tf_df in multi_timeframe_df.items():
                    if tf_df is not None and len(tf_df) > 0:
                        multi_timeframe_data[tf] = tf_df
            finally:
                loop.close()
        except Exception as e:
            logger.warning(f"Failed to fetch multi-timeframe data from Binance: {e}")
            # Fallback: use cached data from fetch_market_data for each timeframe
            for tf in timeframes:
                try:
                    tf_df, _ = fetch_market_data(symbol, tf, num_bars=200, force_refresh=False)
                    if tf_df is not None and len(tf_df) > 0:
                        multi_timeframe_data[tf] = tf_df
                except Exception as tf_e:
                    logger.warning(f"Failed to fetch {tf} data: {tf_e}")

        # Generate convergence signal with multi-timeframe data
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            convergence_signal = loop.run_until_complete(
                signal_generator.generate_convergence_signal(symbol, market_data, multi_timeframe_data)
            )
        finally:
            loop.close()

        # Check for errors
        if convergence_signal.get('error', False):
            status = "Error"
            action = "N/A"
            action_style = {'color': '#ff4444', 'fontSize': '16px', 'fontWeight': 'bold'}
            confidence = "0%"
            alignment_score = "0.0"
            regime = "N/A"
            entry_price = "$0.00"
            stop_loss = "$0.00"
            take_profit = "$0.00"
            risk_reward = "0:0"
            conditions = [html.Span("Error generating signal", style={'color': '#ff4444'})]
            reasoning = convergence_signal.get('reasoning', 'Error occurred')

        else:
            # Extract signal data
            status = "Active"
            action = convergence_signal.get('action', 'HOLD')
            confidence_pct = convergence_signal.get('confidence', 0) * 100
            alignment_score_val = convergence_signal.get('alignment_score', 0)
            regime = convergence_signal.get('regime', 'N/A')
            entry_price_val = convergence_signal.get('entry_price', 0)
            stop_loss_val = convergence_signal.get('stop_loss', 0)
            take_profit_val = convergence_signal.get('take_profit', 0)
            risk_reward_ratio = convergence_signal.get('risk_reward_ratio', 0)
            satisfied_conditions = convergence_signal.get('satisfied_conditions', [])

            # Format action styling
            if action == 'LONG':
                action_style = {'color': '#00ff88', 'fontSize': '16px', 'fontWeight': 'bold'}
            elif action == 'SHORT':
                action_style = {'color': '#ff4444', 'fontSize': '16px', 'fontWeight': 'bold'}
            else:
                action_style = {'color': '#888', 'fontSize': '16px', 'fontWeight': 'bold'}

            # Format values
            confidence = f"{confidence_pct:.1f}%"
            alignment_score = f"{alignment_score_val:.2f}"
            entry_price = f"${entry_price_val:,.2f}" if entry_price_val > 0 else "$0.00"
            stop_loss = f"${stop_loss_val:,.2f}" if stop_loss_val > 0 else "$0.00"
            take_profit = f"${take_profit_val:,.2f}" if take_profit_val > 0 else "$0.00"
            risk_reward = f"1:{risk_reward_ratio:.2f}" if risk_reward_ratio > 0 else "0:0"

            # Format conditions
            if satisfied_conditions:
                conditions = [
                    html.Span(
                        f"âœ“ {cond.replace('_', ' ').title()}",
                        style={
                            'display': 'inline-block',
                            'backgroundColor': '#00ff88',
                            'color': '#000',
                            'padding': '4px 8px',
                            'margin': '2px',
                            'borderRadius': '4px',
                            'fontSize': '11px',
                            'fontWeight': 'bold'
                        }
                    )
                    for cond in satisfied_conditions
                ]
            else:
                conditions = [html.Span("No conditions met", style={'color': '#666', 'fontStyle': 'italic'})]

            # Format reasoning
            reasoning = convergence_signal.get('reasoning', 'No reasoning provided')

        return (
            status,
            action,
            action_style,
            confidence,
            alignment_score,
            regime,
            entry_price,
            stop_loss,
            take_profit,
            risk_reward,
            conditions,
            reasoning
        )

    except Exception as e:
        logger.error(f"Error updating convergence strategy: {e}")
        import traceback
        traceback.print_exc()

        # Return error state
        error_msg = f"Error: {str(e)}"
        return (
            "Error",
            "N/A",
            {'color': '#ff4444', 'fontSize': '16px', 'fontWeight': 'bold'},
            "0%",
            "0.0",
            "N/A",
            "$0.00",
            "$0.00",
            "$0.00",
            "0:0",
            [html.Span(error_msg, style={'color': '#ff4444'})],
            error_msg
        )


# Alert Management Callback
@callback(
    [Output('scalp-alert-status', 'children'),
     Output('scalp-alert-status', 'style')],
    [Input('interval-component', 'n_intervals')],
    [State('symbol-dropdown', 'value'),
     State('scalp-entry-price', 'children'),
     State('scalp-stop-loss', 'children'),
     State('scalp-take-profit-1', 'children'),
     State('scalp-take-profit-2', 'children')]
)
def update_alerts(n_intervals, symbol, entry_price_str, stop_loss_str, tp1_str, tp2_str):
    """Check alerts against current price."""
    try:
        # Initialize alert manager if not already done
        if not hasattr(update_alerts, '_alert_manager'):
            from ops.alerts import get_alert_manager
            update_alerts._alert_manager = get_alert_manager()

        # Get current price from chart data
        df, _ = fetch_market_data(symbol, '15m', num_bars=1, force_refresh=True)
        current_price = df['close'].iloc[-1]

        # Parse prices from string format (remove $ and commas)
        def parse_price(price_str):
            if not price_str or price_str == "$0.00":
                return 0.0
            return float(price_str.replace('$', '').replace(',', ''))

        entry_price = parse_price(entry_price_str)
        stop_loss = parse_price(stop_loss_str)
        tp1 = parse_price(tp1_str)
        tp2 = parse_price(tp2_str)

        # Check for triggered alerts
        alerts = update_alerts._alert_manager.check_thresholds(symbol, current_price)

        # Get active threshold count
        active_count = len(update_alerts._alert_manager.get_active_thresholds(symbol))

        # Format status
        if alerts:
            status = f"ðŸš¨ {len(alerts)} Alert(s) Triggered"
            style = {'color': '#ff4444', 'fontSize': '14px', 'fontWeight': 'bold'}
            logger.warning(f"Alert triggered for {symbol}: {alerts}")
        elif active_count > 0:
            status = f"ðŸ”” Monitoring {active_count} Alert(s)"
            style = {'color': '#00ff88', 'fontSize': '14px', 'fontWeight': 'bold'}
        else:
            status = "No Active Alerts"
            style = {'color': '#888', 'fontSize': '14px', 'fontWeight': 'normal'}

        return status, style

    except Exception as e:
        logger.error(f"Error checking alerts: {e}")
        return "Alert Error", {'color': '#ff9900', 'fontSize': '14px', 'fontWeight': 'bold'}


# Scalp Strategy Callback
@callback(
    [Output('scalp-status', 'children'),
     Output('scalp-action', 'children'),
     Output('scalp-action', 'style'),
     Output('scalp-confidence', 'children'),
     Output('scalp-entry-type', 'children'),
     Output('scalp-entry-price', 'children'),
     Output('scalp-stop-loss', 'children'),
     Output('scalp-take-profit-1', 'children'),
     Output('scalp-take-profit-2', 'children'),
     Output('scalp-entry-zone', 'children'),
     Output('scalp-position-size', 'children'),
     Output('scalp-reasoning', 'children')],
    [Input('scalp-run-btn', 'n_clicks'),
     Input('refresh-scalp-btn', 'n_clicks'),
     Input('interval-component', 'n_intervals')],
    [State('symbol-dropdown', 'value'),
     State('timeframe-store', 'data')]
)
def update_scalp_strategy(run_clicks, refresh_clicks, n_intervals, symbol, timeframe):
    """Update scalp strategy panel with latest signal."""
    ctx = callback_context
    trigger = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else 'unknown'

    # Only run on button click or periodic refresh
    if trigger not in ['scalp-run-btn', 'refresh-scalp-btn', 'interval-component']:
        raise PreventUpdate

    try:
        # Import necessary modules
        from core.signal_generator import SignalGenerator
        from core.system_context import SystemContext
        from features.engine import FeatureEngine

        # Initialize components
        system_context = SystemContext()
        feature_engine = FeatureEngine()
        signal_generator = SignalGenerator(
            system_context=system_context,
            deepseek_brain=None,  # Not needed for signal generation
            feature_engine=feature_engine,
            enable_scalp_strategy=True
        )

        # Fetch 15m data for scalp strategy
        df_15m, fetch_meta = fetch_market_data(symbol, '15m', num_bars=500, force_refresh=True)

        # Convert DataFrame to dict format expected by signal generator
        market_data = {
            'open': df_15m['open'],
            'high': df_15m['high'],
            'low': df_15m['low'],
            'close': df_15m['close'],
            'volume': df_15m['volume']
        }

        # Fetch 4h data for context
        timeframe_data = {}
        try:
            df_4h, _ = fetch_market_data(symbol, '4h', num_bars=200, force_refresh=False)
            if df_4h is not None and len(df_4h) > 0:
                timeframe_data['4h'] = df_4h
        except Exception as e:
            logger.warning(f"Failed to fetch 4h data for scalp strategy: {e}")

        # Generate scalp signal
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            scalp_signal = loop.run_until_complete(
                signal_generator.generate_scalp_signal(symbol, market_data, timeframe_data)
            )
        finally:
            loop.close()

        # Check for errors
        if scalp_signal.get('error', False):
            status = "Error"
            action = "N/A"
            action_style = {'color': '#ff4444', 'fontSize': '16px', 'fontWeight': 'bold'}
            confidence = "0%"
            entry_type = "N/A"
            entry_price = "$0.00"
            stop_loss = "$0.00"
            take_profit_1 = "$0.00"
            take_profit_2 = "$0.00"
            entry_zone = "N/A"
            position_size = "0%"
            reasoning = scalp_signal.get('reasoning', 'Error generating signal')

        else:
            # Extract signal data
            status = "Active"
            action = scalp_signal.get('action', 'WAIT')
            confidence_val = scalp_signal.get('confidence', 0) * 100
            entry_type = scalp_signal.get('entry_type', 'N/A')
            entry_price_val = scalp_signal.get('entry_price', 0)
            stop_loss_val = scalp_signal.get('stop_loss', 0)
            take_profit_1_val = scalp_signal.get('take_profit_1', 0)
            take_profit_2_val = scalp_signal.get('take_profit_2', 0)
            position_size_val = scalp_signal.get('position_size', 0)
            reasoning = scalp_signal.get('reasoning', 'No reasoning provided')

            # Format action styling
            if action == 'LONG':
                action_style = {'color': '#00ff88', 'fontSize': '16px', 'fontWeight': 'bold'}
            elif action == 'SHORT':
                action_style = {'color': '#ff4444', 'fontSize': '16px', 'fontWeight': 'bold'}
            else:
                action_style = {'color': '#888', 'fontSize': '16px', 'fontWeight': 'bold'}

            # Format values
            confidence = f"{confidence_val:.1f}%"
            entry_price = f"${entry_price_val:,.2f}" if entry_price_val > 0 else "$0.00"
            stop_loss = f"${stop_loss_val:,.2f}" if stop_loss_val > 0 else "$0.00"
            take_profit_1 = f"${take_profit_1_val:,.2f}" if take_profit_1_val > 0 else "$0.00"
            take_profit_2 = f"${take_profit_2_val:,.2f}" if take_profit_2_val > 0 else "$0.00"
            position_size = f"{position_size_val:.2%}" if position_size_val > 0 else "0%"

            # Format entry zone/trigger
            entry_zone_text = ""
            if scalp_signal.get('entry_zone'):
                zone = scalp_signal['entry_zone']
                if isinstance(zone, (list, tuple)) and len(zone) == 2:
                    entry_zone_text = f"Zone: ${zone[0]:,.2f} - ${zone[1]:,.2f}"
                else:
                    entry_zone_text = f"Zone: ${zone:,.2f}"
            elif scalp_signal.get('entry_trigger'):
                entry_zone_text = f"Trigger: ${scalp_signal['entry_trigger']:,.2f}"
            else:
                entry_zone_text = "N/A"

        return (
            status,
            action,
            action_style,
            confidence,
            entry_type,
            entry_price,
            stop_loss,
            take_profit_1,
            take_profit_2,
            entry_zone if 'entry_zone' in locals() else entry_zone_text,
            position_size,
            reasoning
        )

    except Exception as e:
        logger.error(f"Error updating scalp strategy: {e}")
        import traceback
        traceback.print_exc()

        # Return error state
        error_msg = f"Error: {str(e)}"
        return (
            "Error",
            "N/A",
            {'color': '#ff4444', 'fontSize': '16px', 'fontWeight': 'bold'},
            "0%",
            "N/A",
            "$0.00",
            "$0.00",
            "$0.00",
            "$0.00",
            "N/A",
            "0%",
            error_msg
        )


# Alert Setup Callback
@callback(
    [Output('setup-alerts-btn', 'style'),
     Output('setup-alerts-btn', 'children'),
     Output('scalp-alert-status', 'children', allow_duplicate=True),
     Output('scalp-alert-status', 'style', allow_duplicate=True)],
    [Input('setup-alerts-btn', 'n_clicks')],
    [State('symbol-dropdown', 'value'),
     State('scalp-entry-price', 'children'),
     State('scalp-stop-loss', 'children'),
     State('scalp-take-profit-1', 'children'),
     State('scalp-take-profit-2', 'children'),
     State('scalp-confidence', 'children'),
     State('scalp-entry-type', 'children')],
    prevent_initial_call=True
)
def setup_alerts(setup_clicks, symbol, entry_price_str, stop_loss_str, tp1_str, tp2_str,
                 confidence_str, entry_type):
    """Setup price alerts based on current signal."""
    ctx = callback_context
    trigger = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else None

    if trigger != 'setup-alerts-btn' or not setup_clicks:
        raise PreventUpdate

    try:
        from ops.alerts import get_alert_manager

        # Get alert manager
        alert_manager = get_alert_manager()

        # Parse prices
        def parse_price(price_str):
            if not price_str or price_str == "$0.00":
                return 0.0
            return float(price_str.replace('$', '').replace(',', ''))

        entry_price = parse_price(entry_price_str)
        stop_loss = parse_price(stop_loss_str)
        tp1 = parse_price(tp1_str)
        tp2 = parse_price(tp2_str)

        # Parse confidence
        confidence = 0.0
        if confidence_str and confidence_str != "0%":
            confidence = float(confidence_str.replace('%', '')) / 100.0

        # Get current price
        df, _ = fetch_market_data(symbol, '15m', num_bars=1, force_refresh=True)
        current_price = df['close'].iloc[-1]

        # Determine direction (for LONG, we're buying dips, so entry is below current)
        direction = "below" if entry_price < current_price else "above"

        # Setup metadata
        metadata = {
            "confidence": confidence,
            "entry_type": entry_type
        }

        # Clear existing alerts for this symbol
        alert_manager.clear_thresholds(symbol)

        # Setup alerts
        thresholds_created = []

        if entry_price > 0:
            alert_manager.add_threshold(
                symbol, "entry", entry_price, current_price, direction, metadata
            )
            thresholds_created.append(f"Entry {direction} {entry_price:.2f}")

        if stop_loss > 0:
            # Stop loss is typically below entry for LONG, above for SHORT
            sl_direction = "below" if stop_loss < entry_price else "above"
            alert_manager.add_threshold(
                symbol, "stop_loss", stop_loss, current_price, sl_direction, metadata
            )
            thresholds_created.append(f"Stop Loss {sl_direction} {stop_loss:.2f}")

        if tp1 > 0:
            tp1_direction = "above" if tp1 > entry_price else "below"
            alert_manager.add_threshold(
                symbol, "take_profit_1", tp1, current_price, tp1_direction, metadata
            )
            thresholds_created.append(f"TP1 {tp1_direction} {tp1:.2f}")

        if tp2 > 0:
            tp2_direction = "above" if tp2 > entry_price else "below"
            alert_manager.add_threshold(
                symbol, "take_profit_2", tp2, current_price, tp2_direction, metadata
            )
            thresholds_created.append(f"TP2 {tp2_direction} {tp2:.2f}")

        # Update button state
        button_style = {
            'backgroundColor': '#666',
            'color': 'white',
            'border': 'none',
            'padding': '10px 25px',
            'cursor': 'not-allowed',
            'borderRadius': '5px',
            'fontSize': '14px',
            'fontWeight': 'bold',
            'marginRight': '10px',
            'opacity': '0.7'
        }
        button_children = f"âœ“ Alerts Set ({len(thresholds_created)})"

        # Update alert status
        status = f"ðŸ”” Monitoring {len(thresholds_created)} Alert(s)"
        status_style = {'color': '#00ff88', 'fontSize': '14px', 'fontWeight': 'bold'}

        logger.info(f"Setup alerts for {symbol}: {', '.join(thresholds_created)}")

        return button_style, button_children, status, status_style

    except Exception as e:
        logger.error(f"Error setting up alerts: {e}")
        button_style = {
            'backgroundColor': '#ff9900',
            'color': 'black',
            'border': 'none',
            'padding': '10px 25px',
            'cursor': 'pointer',
            'borderRadius': '5px',
            'fontSize': '14px',
            'fontWeight': 'bold',
            'marginRight': '10px'
        }
        button_children = "ðŸ”” Setup Alerts"
        status = "Alert Setup Error"
        status_style = {'color': '#ff4444', 'fontSize': '14px', 'fontWeight': 'bold'}

        return button_style, button_children, status, status_style


# Alert Clear Callback
@callback(
    [Output('clear-alerts-btn', 'style'),
     Output('clear-alerts-btn', 'children'),
     Output('setup-alerts-btn', 'style', allow_duplicate=True),
     Output('setup-alerts-btn', 'children', allow_duplicate=True),
     Output('scalp-alert-status', 'children', allow_duplicate=True),
     Output('scalp-alert-status', 'style', allow_duplicate=True)],
    [Input('clear-alerts-btn', 'n_clicks')],
    [State('symbol-dropdown', 'value')],
    prevent_initial_call=True
)
def clear_alerts(clear_clicks, symbol):
    """Clear all alerts for a symbol."""
    ctx = callback_context
    trigger = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else None

    if trigger != 'clear-alerts-btn' or not clear_clicks:
        raise PreventUpdate

    try:
        from ops.alerts import get_alert_manager

        # Get alert manager
        alert_manager = get_alert_manager()

        # Clear alerts
        alert_manager.clear_thresholds(symbol)

        # Update clear button state
        clear_button_style = {
            'backgroundColor': '#666',
            'color': 'white',
            'border': 'none',
            'padding': '10px 25px',
            'cursor': 'not-allowed',
            'borderRadius': '5px',
            'fontSize': '14px',
            'fontWeight': 'bold',
            'marginRight': '10px',
            'opacity': '0.7'
        }
        clear_button_children = "âœ“ Cleared"

        # Reset setup button
        setup_button_style = {
            'backgroundColor': '#00ff88',
            'color': 'black',
            'border': 'none',
            'padding': '10px 25px',
            'cursor': 'pointer',
            'borderRadius': '5px',
            'fontSize': '14px',
            'fontWeight': 'bold',
            'marginRight': '10px'
        }
        setup_button_children = "ðŸ”” Setup Alerts"

        # Update alert status
        status = "No Active Alerts"
        status_style = {'color': '#888', 'fontSize': '14px', 'fontWeight': 'normal'}

        logger.info(f"Cleared all alerts for {symbol}")

        return clear_button_style, clear_button_children, setup_button_style, setup_button_children, status, status_style

    except Exception as e:
        logger.error(f"Error clearing alerts: {e}")
        return (
            dash.no_update,  # clear button style
            dash.no_update,  # clear button children
            dash.no_update,  # setup button style
            dash.no_update,  # setup button children
            "Alert Clear Error",
            {'color': '#ff4444', 'fontSize': '14px', 'fontWeight': 'bold'}
        )


@callback(
    Output('chart-view-store', 'data'),
    Input('price-chart', 'relayoutData'),
    State('chart-view-store', 'data'),
    State('timeframe-store', 'data'),
    State('symbol-dropdown', 'value'),
    prevent_initial_call=True
)
def persist_chart_zoom(relayout_data, stored_views, timeframe, symbol):
    """Track manual zoom/pan ranges so they survive refresh cycles."""
    stored_views = stored_views or {}
    if not relayout_data:
        return stored_views

    view_key = f"{symbol}:{timeframe}"
    updated_store = stored_views.copy()

    # Reset view when autorange or resetScale invoked
    if any(flag in relayout_data and relayout_data.get(flag) in (True, 'reversed')
           for flag in ['xaxis.autorange', 'yaxis.autorange']):
        updated_store.pop(view_key, None)
        return updated_store

    def extract_range(prefix: str):
        if f'{prefix}.range[0]' in relayout_data and f'{prefix}.range[1]' in relayout_data:
            return [
                relayout_data[f'{prefix}.range[0]'],
                relayout_data[f'{prefix}.range[1]']
            ]
        value = relayout_data.get(f'{prefix}.range')
        if isinstance(value, (list, tuple)) and len(value) == 2:
            return list(value)
        return None

    x_range = extract_range('xaxis')
    y_range = extract_range('yaxis')

    if not x_range and not y_range:
        return updated_store

    entry = updated_store.get(view_key, {})
    if x_range:
        entry['x'] = x_range
    if y_range:
        entry['y'] = y_range
    updated_store[view_key] = entry
    return updated_store


# Performance Monitoring Callback (W2.3)
@callback(
    [Output('perf-fps', 'children'),
     Output('perf-memory', 'children'),
     Output('perf-render', 'children'),
     Output('perf-cache', 'children'),
     Output('performance-metrics', 'style')],
    [Input('interval-component', 'n_intervals')],
    [State('market-data-store', 'data'),
     State('chart-view-store', 'data')]
)
def update_performance_metrics(n_intervals, market_data, chart_view_store):
    """Update real-time performance metrics display."""
    try:
        import psutil
        import time

        # Calculate FPS based on update interval (assuming 2s interval)
        interval_seconds = 2.0
        fps = min(60.0, interval_seconds / max(0.016, time.time() - (update_performance_metrics._last_update or time.time())))
        update_performance_metrics._last_update = time.time()

        # Get memory usage
        process = psutil.Process()
        memory_mb = process.memory_info().rss / 1024 / 1024

        # Estimate render time (simulated - in production, would use performance.now())
        render_time_ms = 12.5  # Typical chart render time

        # Calculate cache hit rate (simulated based on data freshness)
        cache_hit_rate = "87%"

        # Show performance metrics (hidden by default, shown when updates are active)
        display_style = {
            'display': 'block',
            'position': 'fixed',
            'bottom': '20px',
            'right': '20px',
            'backgroundColor': 'rgba(26, 26, 26, 0.95)',
            'padding': '15px 20px',
            'borderRadius': '8px',
            'border': '1px solid rgba(68, 136, 255, 0.3)',
            'boxShadow': '0 4px 12px rgba(0, 0, 0, 0.5)',
            'zIndex': 9999,
            'minWidth': '240px',
            'backdropFilter': 'blur(8px)',
            'fontFamily': 'monospace'
        }

        return (
            f"{fps:.0f}",
            f"{memory_mb:.0f} MB",
            f"{render_time_ms:.0f}ms",
            cache_hit_rate,
            display_style
        )
    except Exception as e:
        logger.error(f"Error updating performance metrics: {e}")
        # Return default values on error
        return "0", "0 MB", "0ms", "--", {'display': 'none'}


# W2.4: Keyboard Navigation Callback
@callback(
    [Output('tf-1m', 'n_clicks'),
     Output('tf-5m', 'n_clicks'),
     Output('tf-15m', 'n_clicks'),
     Output('tf-1h', 'n_clicks'),
     Output('tf-4h', 'n_clicks'),
     Output('tf-1d', 'n_clicks'),
     Output('aria-live-region', 'children')],
    [Input('interval-component', 'n_intervals')],
    [State('timeframe-store', 'data')],
    prevent_initial_call=True
)
def handle_keyboard_shortcuts(n_intervals, current_timeframe):
    """Handle keyboard shortcuts for timeframe switching (Ctrl+1 through Ctrl+6)."""
    import json
    from flask import request

    try:
        # Get the raw request data from Dash
        # Note: In a production environment, you'd use a proper keyboard event listener
        # For now, this simulates keyboard shortcuts

        # Announce current timeframe to screen readers
        announcement = f"Current timeframe is {current_timeframe}"

        # No direct keyboard event handling in Dash without custom JavaScript
        # This is a placeholder for keyboard shortcut integration
        # In practice, you'd need to use custom JavaScript with Dash clientside_callback

        return 0, 0, 0, 0, 0, 0, announcement

    except Exception as e:
        logger.error(f"Error handling keyboard shortcuts: {e}")
        return 0, 0, 0, 0, 0, 0, f"Timeframe: {current_timeframe}"


# W2.4: Notification System Callback
@callback(
    [Output('aria-live-region', 'children', allow_duplicate=True)],
    [Input('interval-component', 'n_intervals')],
    [State('trading-status-store', 'data'),
     State('live-price', 'children')],
    prevent_initial_call=False
)
def update_notifications(n_intervals, trading_status, current_price):
    """Update notifications and announcements for accessibility."""
    try:
        # Announce significant changes to screen readers
        announcements = []

        # Announce trading status changes
        if trading_status and trading_status.get('running', False):
            announcements.append(f"Trading system is running. Current price: {current_price}")

        return " | ".join(announcements) if announcements else ""

    except Exception as e:
        logger.error(f"Error updating notifications: {e}")
        return ""


# Reset overlays callback
@callback(
    Output('feature-toggles', 'value'),
    Input('reset-overlays-btn', 'n_clicks'),
    prevent_initial_call=True
)
def reset_overlays(n_clicks):
    """Reset all overlays to default enabled state."""
    if not n_clicks:
        raise PreventUpdate

    logger.info("Resetting overlays to default state")
    return ['liquidity', 'supertrend', 'chandelier', 'orderflow', 'regime']


# Emergency stop callback
@callback(
    [Output('emergency-stop-btn', 'style')],
    [Input('emergency-stop-btn', 'n_clicks')]
)
def emergency_stop_click(n_clicks):
    """Handle emergency stop button click."""
    if n_clicks > 0:
        logger.warning("Emergency stop triggered from dashboard")
        return [{'backgroundColor': '#ffaa00', 'color': 'white', 'border': 'none', 'padding': '12px 30px', 'cursor': 'pointer', 'fontSize': '14px', 'fontWeight': 'bold', 'borderRadius': '5px'}]

    return [{'backgroundColor': '#ff4444', 'color': 'white', 'border': 'none', 'padding': '12px 30px', 'cursor': 'pointer', 'fontSize': '14px', 'fontWeight': 'bold', 'borderRadius': '5px'}]


# Feature Profile Callbacks
PROFILE_SCALP = ['liquidity', 'orderflow', 'alignment']
PROFILE_SWING = ['liquidity', 'supertrend', 'chandelier', 'regime']

@callback(
    [Output('profile-scalp-btn', 'style'),
     Output('profile-swing-btn', 'style'),
     Output('profile-custom-btn', 'style'),
     Output('feature-toggles', 'value')],
    [Input('profile-scalp-btn', 'n_clicks'),
     Input('profile-swing-btn', 'n_clicks'),
     Input('profile-custom-btn', 'n_clicks')],
    [State('feature-toggles', 'value')],
    prevent_initial_call=True
)
def switch_feature_profile(scalp_clicks, swing_clicks, custom_clicks, current_toggles):
    """Switch between feature profiles (Scalp, Swing, Custom)."""
    ctx = callback_context
    trigger = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else None

    if not trigger:
        raise PreventUpdate

    # Base button style
    base_style = {
        'backgroundColor': '#1a1a1a',
        'color': 'white',
        'border': '1px solid #444',
        'padding': '8px 20px',
        'cursor': 'pointer',
        'borderRadius': '5px',
        'fontSize': '13px',
        'fontWeight': 'bold',
        'marginRight': '10px'
    }
    active_style = {
        'backgroundColor': '#00ff88',
        'color': 'black',
        'border': '1px solid #00ff88',
        'padding': '8px 20px',
        'cursor': 'pointer',
        'borderRadius': '5px',
        'fontSize': '13px',
        'fontWeight': 'bold',
        'marginRight': '10px'
    }

    scalp_style = base_style.copy()
    swing_style = base_style.copy()
    custom_style = base_style.copy()

    if trigger == 'profile-scalp-btn' and scalp_clicks:
        scalp_style = active_style.copy()
        new_toggles = PROFILE_SCALP
        selected_profile = "scalp"
        logger.info("Switched to Scalp mode profile")
    elif trigger == 'profile-swing-btn' and swing_clicks:
        swing_style = active_style.copy()
        new_toggles = PROFILE_SWING
        selected_profile = "swing"
        logger.info("Switched to Swing mode profile")
    elif trigger == 'profile-custom-btn' and custom_clicks:
        custom_style = active_style.copy()
        new_toggles = current_toggles  # Keep current toggles
        selected_profile = "custom"
        logger.info("Switched to Custom mode profile")
    else:
        # No change
        raise PreventUpdate

    # Update SystemContext with the selected profile
    if CHAT_SYSTEM_CONTEXT:
        try:
            CHAT_SYSTEM_CONTEXT.update_feature_profile(selected_profile)
            logger.info(f"Updated SystemContext with profile: {selected_profile}")
        except Exception as e:
            logger.warning(f"Failed to update profile in SystemContext: {e}")

    return scalp_style, swing_style, custom_style, new_toggles


def save_chat_to_log(message_data: Dict[str, Any]):
    """Save chat message to log file."""
    try:
        os.makedirs('logs', exist_ok=True)
        with open('logs/chat_history.log', 'a', encoding='utf-8') as f:
            timestamp = message_data.get('timestamp', datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
            sender = "USER" if message_data.get('is_user', True) else "DEEPSEEK"
            text = message_data.get('text', '')
            f.write(f"[{timestamp}] {sender}: {text}\n")
    except Exception as e:
        logger.error(f"Failed to save chat log: {e}")


# Chat interface callbacks
@callback(
    [Output('chat-store', 'data'),
     Output('chat-history', 'children'),
     Output('chat-status', 'children'),
     Output('chat-input', 'value')],
    [Input('chat-send-button', 'n_clicks'),
     Input('chat-clear-button', 'n_clicks'),
     Input('chat-analyze-perf', 'n_clicks'),
     Input('chat-market-analysis', 'n_clicks'),
     Input('chat-risk-assessment', 'n_clicks'),
     Input('chat-system-opt', 'n_clicks'),
     Input('chat-feature-perf', 'n_clicks'),
     Input('chat-close-positions', 'n_clicks'),
     Input('chat-pause-trading', 'n_clicks'),
     Input('chat-resume-trading', 'n_clicks'),
     Input('chat-convergence-btn', 'n_clicks'),
     Input('chat-scalp-btn', 'n_clicks')],
    [State('chat-input', 'value'),
     State('chat-store', 'data'),
     State('timeframe-store', 'data')]
)
def update_chat(send_clicks, clear_clicks, analyze_clicks, market_clicks, risk_clicks,
                system_clicks, feature_clicks, close_clicks, pause_clicks, resume_clicks,
                chat_convergence_clicks, chat_scalp_clicks, input_text, chat_history, current_timeframe):
    """Update chat history with file logging."""
    ctx = callback_context
    trigger = ctx.triggered[0]['prop_id'].split('.')[0] if ctx.triggered else None
    chat_history = chat_history or []
    sanitized_text = (input_text or '').strip() if input_text else ''

    # Update GLOBAL_STATE with current timeframe from store for chat context
    if current_timeframe:
        logger.info(f"[DIAGNOSTIC] Chat callback received timeframe from store: {current_timeframe}")
        GLOBAL_STATE['selected_timeframe'] = current_timeframe

    # Clear chat
    if trigger and 'clear-button' in trigger and clear_clicks > 0:
        save_chat_to_log({'is_user': False, 'text': 'Chat cleared by user', 'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')})
        return [], [html.Div([
            html.Div("DeepSeek AI", style={'fontWeight': 'bold', 'marginBottom': '5px', 'color': '#4488ff'}),
            html.Div('Chat cleared. How can I help you?', style={
                'backgroundColor': '#1a1a1a', 'padding': '15px', 'borderRadius': '8px',
                'maxWidth': '70%', 'borderLeft': '3px solid #4488ff'
            }),
            html.Div(datetime.now().strftime('%H:%M:%S'), style={'fontSize': '10px', 'color': '#666', 'marginTop': '5px'})
        ], style={'marginBottom': '15px'})], 'Chat cleared âœ“', ''

    # Send message
    if trigger and 'send-button' in trigger and send_clicks > 0:
        if not sanitized_text:
            return chat_history, render_chat_history(chat_history), 'Please enter a message before sending.', input_text

        # Check if this is a backtest command (W1.3)
        backtest_config = parse_backtest_command(sanitized_text)
        if backtest_config:
            # Process backtest command directly
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

            # Add user message
            user_message = {
                'is_user': True,
                'text': sanitized_text,
                'timestamp': timestamp
            }
            save_chat_to_log(user_message)

            # Call backtest API
            logger.info(f"Processing backtest command from chat: {backtest_config}")
            api_response = call_backtest_api(backtest_config)

            # Format response
            ai_text = format_backtest_chat_response(backtest_config, api_response)
            ai_message = {
                'is_user': False,
                'text': ai_text,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
            save_chat_to_log(ai_message)

            # Update history
            updated_history = chat_history + [user_message, ai_message]
            status_msg = "Backtest executed via chat âœ“ | Logged to: logs/chat_history.log"

            return updated_history, render_chat_history(updated_history), status_msg, ''

        # Otherwise, process normally via DeepSeek
        updated_history, message_components, status_msg = process_chat_request(
            chat_history,
            sanitized_text,
            "strategy",
            "Message sent"
        )
        return updated_history, message_components, status_msg, ''

    # Quick action messages
    action_messages = {
        'chat-analyze-perf': 'Please analyze our recent trading performance and suggest improvements.',
        'chat-market-analysis': 'Provide a deep analysis of current market conditions and opportunities.',
        'chat-risk-assessment': 'Evaluate our current risk exposure and suggest management strategies.',
        'chat-system-opt': 'Identify system bottlenecks and suggest performance improvements.',
        'chat-feature-perf': 'Review current feature effectiveness and recommend adjustments.',
        'chat-close-positions': 'Please close all open positions immediately.',
        'chat-pause-trading': 'Pause all trading activities.',
        'chat-resume-trading': 'Resume normal trading operations.',
        'chat-convergence-btn': 'Please run the Multi-Timeframe Convergence Strategy and provide a detailed analysis of the current signal, including alignment score, market regime, and satisfied conditions.',
        'chat-scalp-btn': 'Please run the 15m Scalp with 4h Awareness Strategy and provide a detailed analysis of the current setup, including entry type (pullback/breakout), entry zones, stop loss, take profit levels, and position sizing.'
    }
    action_types = {
        'chat-analyze-perf': 'performance',
        'chat-market-analysis': 'market',
        'chat-risk-assessment': 'risk',
        'chat-system-opt': 'system',
        'chat-feature-perf': 'features',
        'chat-close-positions': 'orders',
        'chat-pause-trading': 'control',
        'chat-resume-trading': 'control',
        'chat-convergence-btn': 'convergence',
        'chat-scalp-btn': 'scalp'
    }

    if trigger and trigger in action_messages:
        message_text = action_messages[trigger]
        message_type = action_types.get(trigger, 'system')
        updated_history, message_components, status_msg = process_chat_request(
            chat_history,
            message_text,
            message_type,
            "Quick action executed"
        )
        return updated_history, message_components, status_msg, ''

    # Return current state
    return chat_history, render_chat_history(chat_history), 'Chat history saved to: logs/chat_history.log', input_text


# Trading Control Callback
@callback(
    Output('trading-status-text', 'children'),
    Output('start-trading-btn', 'style'),
    Output('start-trading-btn', 'children'),
    Output('trading-status-store', 'data'),
    Input('start-trading-btn', 'n_clicks'),
    Input('emergency-stop-btn', 'n_clicks'),
    prevent_initial_call=True
)
def control_trading_system(start_clicks, stop_clicks):
    """Control the trading system start/stop."""
    ctx = callback_context
    if not ctx.triggered:
        # Get initial status
        status = get_trading_status()
        return format_status_message(status), get_start_button_style(status), get_start_button_text(status), status

    trigger = ctx.triggered[0]['prop_id'].split('.')[0]

    try:
        if trigger == 'start-trading-btn' and start_clicks:
            result = start_trading()
            status = get_trading_status()
            return result['message'], get_start_button_style(status), get_start_button_text(status), status

        elif trigger == 'emergency-stop-btn' and stop_clicks:
            result = stop_trading()
            status = get_trading_status()
            return result['message'], get_start_button_style(status), get_start_button_text(status), status

        # Get current status
        status = get_trading_status()
        return format_status_message(status), get_start_button_style(status), get_start_button_text(status), status

    except Exception as e:
        error_msg = f"Error: {str(e)}"
        status = {'running': False, 'status': 'error'}
        return error_msg, get_start_button_style(status), get_start_button_text(status), status


def get_trading_status():
    """Get trading system status using the helper."""
    from scripts.trading_control import get_status
    return get_status()


def start_trading():
    """Start trading system using the helper."""
    from scripts.trading_control import start_trading
    return start_trading()


def stop_trading():
    """Stop trading system using the helper."""
    from scripts.trading_control import stop_trading
    return stop_trading()


def format_status_message(status):
    """Format status message for display."""
    if not status['running']:
        if status['status'] == 'stopped':
            return "Trading system: STOPPED"
        elif status['status'] == 'error':
            return f"Trading system: ERROR - {status['status']}"
        else:
            return f"Trading system: {status['status']}"
    else:
        pid = status.get('pid', 'N/A')
        uptime = status.get('uptime_seconds', 0)
        uptime_str = format_uptime(uptime)
        return f"Trading system: RUNNING (PID: {pid}, Uptime: {uptime_str})"


def get_start_button_style(status):
    """Get button style based on status."""
    if status['running']:
        return {
            'backgroundColor': '#ff9800',
            'color': 'white',
            'border': 'none',
            'padding': '12px 30px',
            'cursor': 'not-allowed',
            'marginRight': '10px',
            'fontSize': '14px',
            'fontWeight': 'bold',
            'borderRadius': '5px',
            'opacity': '0.6'
        }
    else:
        return {
            'backgroundColor': '#00d084',
            'color': 'black',
            'border': 'none',
            'padding': '12px 30px',
            'cursor': 'pointer',
            'marginRight': '10px',
            'fontSize': '14px',
            'fontWeight': 'bold',
            'borderRadius': '5px'
        }


def get_start_button_text(status):
    """Get button text based on status."""
    if status['running']:
        return "â¸ï¸ Trading Active"
    else:
        return "START Start Trading"


def format_uptime(seconds):
    """Format uptime in human-readable format."""
    if seconds < 60:
        return f"{int(seconds)}s"
    elif seconds < 3600:
        return f"{int(seconds/60)}m {int(seconds%60)}s"
    else:
        hours = int(seconds / 3600)
        minutes = int((seconds % 3600) / 60)
        return f"{hours}h {minutes}m"


def run_backtest_helper(symbol='BTCUSDT', timeframe='1h', strategy='sma', initial_capital=10000.0):
    """Helper function to run backtest - callable from both UI and DeepSeek chat."""
    try:
        import pandas as pd
        from models.backtester import Backtester
        from datetime import datetime

        # Convert initial_capital to float (in case it comes as string from spinbutton)
        initial_capital = float(initial_capital)

        # Load data - try parquet first, fall back to fetching if not exists
        data_file = f'data/cache/ohlcv_{symbol}_{timeframe}.parquet'
        try:
            df = pd.read_parquet(data_file)
        except (FileNotFoundError, Exception):
            # File doesn't exist, fetch it using fetch_market_data
            logger.info(f"Parquet file not found for {symbol} {timeframe}, fetching data...")
            df, meta = fetch_market_data(symbol, timeframe, num_bars=1000, force_refresh=True)
            if df is None or len(df) == 0:
                raise ValueError(f"Failed to fetch data for {symbol} {timeframe}")

        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df = df.set_index('timestamp')

        # Generate signals based on strategy
        signals = pd.DataFrame(index=df.index)
        signals['signal'] = 0
        signals['strength'] = 0.0
        signals['confidence'] = 0.7

        if strategy == 'sma':
            # SMA crossover strategy
            ma_fast = df['close'].rolling(20).mean()
            ma_slow = df['close'].rolling(50).mean()
            signals.loc[df['close'] > ma_fast, 'signal'] = 1
            signals.loc[df['close'] < ma_fast, 'signal'] = -1
            signals['strength'] = signals['signal'].abs()
            strategy_name = f"{symbol} SMA Crossover (20/50)"
        elif strategy == 'rsi':
            # RSI mean reversion strategy
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            # Avoid division by zero by adding small epsilon
            rs = gain / (loss + 1e-10)
            rsi = 100 - (100 / (1 + rs))
            signals.loc[rsi < 30, 'signal'] = 1  # Oversold - buy
            signals.loc[rsi > 70, 'signal'] = -1  # Overbought - sell
            signals['strength'] = signals['signal'].abs()
            strategy_name = f"{symbol} RSI Mean Reversion"
        elif strategy == 'macd':
            # MACD trend strategy
            exp1 = df['close'].ewm(span=12).mean()
            exp2 = df['close'].ewm(span=26).mean()
            macd = exp1 - exp2
            signal_line = macd.ewm(span=9).mean()
            signals.loc[macd > signal_line, 'signal'] = 1
            signals.loc[macd < signal_line, 'signal'] = -1
            signals['strength'] = signals['signal'].abs()
            strategy_name = f"{symbol} MACD Trend"
        else:
            # Default to SMA
            ma = df['close'].rolling(20).mean()
            signals.loc[df['close'] > ma, 'signal'] = 1
            signals.loc[df['close'] < ma, 'signal'] = -1
            signals['strength'] = signals['signal'].abs()
            strategy_name = f"{symbol} SMA Trend Follow"

        signals = signals.fillna(0)

        # Run backtest
        backtester = Backtester(initial_capital=initial_capital)
        results = backtester.run_backtest(df, signals, strategy_name)

        # Calculate summary metrics
        total_trades = len(results.trades)
        total_pnl = sum(t.pnl for t in results.trades)
        final_capital = initial_capital + total_pnl
        # Avoid division by zero if initial_capital is 0
        total_return_pct = ((final_capital / initial_capital) - 1) * 100 if initial_capital > 0 else 0

        wins = [t for t in results.trades if t.pnl > 0]
        losses = [t for t in results.trades if t.pnl <= 0]
        win_rate = (len(wins) / total_trades * 100) if total_trades > 0 else 0

        # Calculate additional metrics with proper error handling
        avg_win = (sum(t.pnl for t in wins) / len(wins)) if wins else 0
        avg_loss = (sum(t.pnl for t in losses) / len(losses)) if losses else 0
        win_loss_ratio = abs(avg_win/avg_loss) if avg_loss != 0 else 0

        # Prepare summary
        summary = {
            'strategy': strategy_name,
            'symbol': symbol,
            'timeframe': timeframe,
            'initial_capital': initial_capital,
            'final_capital': final_capital,
            'total_pnl': total_pnl,
            'total_return_pct': total_return_pct,
            'total_trades': total_trades,
            'win_rate': win_rate,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'win_loss_ratio': abs(avg_win/avg_loss) if avg_loss != 0 else 0,
            'trades': results.trades
        }

        return summary

    except Exception as e:
        logger.error(f"Backtest error: {e}")
        raise


def format_backtest_results(summary):
    """Format backtest results for display."""
    # Prepare summary table
    summary_children = [
        html.Div([
            html.H4(f"{summary['strategy']} - Results", style={
                'color': '#00ff88',
                'marginBottom': '15px',
                'fontSize': '16px'
            }),
            html.Div([
                html.Div([
                    html.Div("Final Capital", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"${summary['final_capital']:,.2f}", style={
                        'color': '#fff',
                        'fontSize': '20px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),
                html.Div([
                    html.Div("Total Return", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{summary['total_return_pct']:+.2f}%", style={
                        'color': '#00ff88' if summary['total_return_pct'] >= 0 else '#ff4444',
                        'fontSize': '20px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),
                html.Div([
                    html.Div("Total Trades", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{summary['total_trades']}", style={
                        'color': '#fff',
                        'fontSize': '20px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),
                html.Div([
                    html.Div("Win Rate", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{summary['win_rate']:.1f}%", style={
                        'color': '#fff',
                        'fontSize': '20px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'})
            ], style={'display': 'flex', 'flexWrap': 'wrap'}),
            html.Hr(style={'borderColor': '#222', 'margin': '20px 0'}),
            html.Div([
                html.Div([
                    html.Div("Average Win", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"${summary['avg_win']:,.2f}", style={
                        'color': '#00ff88',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),
                html.Div([
                    html.Div("Average Loss", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"${summary['avg_loss']:,.2f}", style={
                        'color': '#ff4444',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),
                html.Div([
                    html.Div("Win/Loss Ratio", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{summary['win_loss_ratio']:.2f}", style={
                        'color': '#fff',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'})
            ], style={'display': 'flex', 'flexWrap': 'wrap'}),
        ])
    ]

    # Prepare raw output
    output_text = f"""Backtest Results - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Strategy: {summary['strategy']}
Symbol: {summary['symbol']} | Timeframe: {summary['timeframe']}

Initial Capital: ${summary['initial_capital']:,.2f}
Final Capital: ${summary['final_capital']:,.2f}
Total P&L: ${summary['total_pnl']:,.2f}
Total Return: {summary['total_return_pct']:+.2f}%

Total Trades: {summary['total_trades']}
Win Rate: {summary['win_rate']:.1f}%
Average Win: ${summary['avg_win']:,.2f}
Average Loss: ${summary['avg_loss']:,.2f}
Win/Loss Ratio: {summary['win_loss_ratio']:.2f}

{'-' * 80}
"""

    # Add individual trades
    for i, trade in enumerate(summary['trades'], 1):
        output_text += f"\n{i}. {trade.side} - {trade.entry_time.strftime('%Y-%m-%d %H:%M')} to {trade.exit_time.strftime('%Y-%m-%d %H:%M')}\n"
        output_text += f"   Entry: ${trade.entry_price:.2f} | Exit: ${trade.exit_price:.2f}\n"
        output_text += f"   P&L: ${trade.pnl:.2f} ({trade.pnl_percent:.2%}) | Reason: {trade.exit_reason}\n"

    output_style = {
        'backgroundColor': '#0d1117',
        'color': '#c9d1d9',
        'padding': '15px',
        'borderRadius': '8px',
        'border': '1px solid #222',
        'fontSize': '12px',
        'maxHeight': '400px',
        'overflow': 'auto',
        'marginTop': '15px'
    }

    return summary_children, output_text, output_style


# ============================================================================
# Backtest Panel Callbacks (W1.2)
# ============================================================================

@callback(
    Output('backtest-status', 'children'),
    Output('backtest-result-store', 'data'),
    Output('backtest-modal', 'is_open'),
    Output('backtest-modal-title', 'children'),
    Output('backtest-modal-body', 'children'),
    Output('backtest-loading', 'style'),
    Input('run-backtest-btn', 'n_clicks'),
    State('backtest-symbol', 'value'),
    State('backtest-timeframe', 'value'),
    State('backtest-strategy', 'value'),
    State('backtest-start-date', 'date'),
    State('backtest-end-date', 'date'),
    State('backtest-capital', 'value'),
    prevent_initial_call=True
)
def run_backtest_api(n_clicks, symbol, timeframe, strategy, start_date, end_date, capital):
    """Run backtest via API and display results in modal."""
    if not n_clicks:
        return dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update, dash.no_update

    # Show loading
    loading_style = {'display': 'block', 'marginTop': '20px'}

    try:
        # Prepare API payload
        payload = {
            'symbol': symbol,
            'timeframe': timeframe,
            'strategy': strategy,
            'start': start_date,
            'end': end_date,
            'initial_capital': float(capital) if capital else 10000.0,
            'params': {}
        }

        # Call the FastAPI endpoint
        response = requests.post(
            'http://localhost:8000/backtest',
            json=payload,
            timeout=30
        )

        if response.status_code == 200:
            result = response.json()
            backtest_data = result.get('result', {})
            config_hash = result.get('config_hash', '')

            # Create results display
            title = f"Backtest Results - {symbol} {timeframe} {strategy.upper()}"

            # Format metrics
            metrics_html = html.Div([
                html.Div([
                    html.Div("Total Return", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{backtest_data.get('total_return_pct', 0):+.2f}%", style={
                        'color': '#00ff88' if backtest_data.get('total_return_pct', 0) >= 0 else '#ff4444',
                        'fontSize': '20px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Sharpe Ratio", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{backtest_data.get('sharpe_ratio', 0):.3f}", style={
                        'color': '#fff',
                        'fontSize': '20px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Max Drawdown", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{backtest_data.get('max_drawdown', 0):.2f}%", style={
                        'color': '#ff4444',
                        'fontSize': '20px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Win Rate", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{backtest_data.get('win_rate', 0):.1f}%", style={
                        'color': '#00ff88',
                        'fontSize': '20px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'}),

            # Additional metrics
            html.Div([
                html.Div([
                    html.Div("Total Trades", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(str(backtest_data.get('total_trades', 0)), style={
                        'color': '#fff',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Initial Capital", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"${backtest_data.get('initial_capital', 0):,.2f}", style={
                        'color': '#fff',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Final Capital", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"${backtest_data.get('final_capital', 0):,.2f}", style={
                        'color': '#00ff88',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1', 'marginRight': '20px'}),

                html.Div([
                    html.Div("Profit Factor", style={'color': '#888', 'fontSize': '12px'}),
                    html.Div(f"{backtest_data.get('profit_factor', 0):.2f}", style={
                        'color': '#fff',
                        'fontSize': '16px',
                        'fontWeight': 'bold'
                    })
                ], style={'flex': '1'})
            ], style={'display': 'flex', 'flexWrap': 'wrap'})
        ], style={'padding': '20px'})

            # Prepare store data
            store_data = {
                'config_hash': config_hash,
                'symbol': symbol,
                'timeframe': timeframe,
                'strategy': strategy,
                'data': backtest_data,
                'timestamp': datetime.now().isoformat()
            }

            status_msg = f"âœ“ Backtest completed successfully"
            return status_msg, store_data, True, title, metrics_html, {'display': 'none'}

        else:
            error_msg = f"API Error: {response.status_code} - {response.text}"
            return error_msg, {}, False, "Error", html.Div(error_msg, style={'color': '#ff4444'}), {'display': 'none'}

    except requests.exceptions.RequestException as e:
        error_msg = f"Connection error: Make sure the backtest API is running on localhost:8000"
        return error_msg, {}, False, "Error", html.Div(error_msg, style={'color': '#ff4444'}), {'display': 'none'}
    except Exception as e:
        logger.error(f"Backtest error: {e}")
        error_msg = f"Error running backtest: {str(e)}"
        return error_msg, {}, False, "Error", html.Div(error_msg, style={'color': '#ff4444'}), {'display': 'none'}


@callback(
    Output('backtest-modal', 'is_open', allow_duplicate=True),
    Input('backtest-modal-close', 'n_clicks'),
    prevent_initial_call=True
)
def close_backtest_modal(n_clicks):
    """Close the backtest results modal."""
    if n_clicks:
        return False
    return dash.no_update


@callback(
    Output('promote-backtest-output', 'children'),
    Input('promote-backtest-btn', 'n_clicks'),
    State('backtest-result-store', 'data'),
    prevent_initial_call=True
)
def promote_backtest(n_clicks, store_data):
    """Promote a backtest to production."""
    if not n_clicks or not store_data:
        return dash.no_update

    try:
        import subprocess

        # Extract experiment ID (in a real implementation, this would come from the database)
        # For now, we'll use a placeholder
        experiment_id = 1  # This should be the actual ID from the database
        profile_name = f"{store_data.get('strategy', 'strategy')}_{store_data.get('symbol', 'symbol')}"

        # Call the promotion script
        cmd = [
            'python', 'scripts/promote_strategy.py',
            str(experiment_id),
            profile_name,
            '--auto-commit'
        ]

        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            cwd='/Users/mrsmoothy/Downloads/Trading_bot'
        )

        if result.returncode == 0:
            return html.Div([
                html.Div("âœ“ Successfully promoted to production!", style={'color': '#00ff88', 'fontWeight': 'bold'}),
                html.Pre(result.stdout, style={'color': '#888', 'fontSize': '12px', 'marginTop': '10px'})
            ])
        else:
            return html.Div([
                html.Div("âœ— Promotion failed", style={'color': '#ff4444', 'fontWeight': 'bold'}),
                html.Pre(result.stderr, style={'color': '#ff4444', 'fontSize': '12px', 'marginTop': '10px'})
            ])

    except Exception as e:
        return html.Div(f"Error promoting: {str(e)}", style={'color': '#ff4444'})


def create_dashboard_app():
    """Create the Dash app with design system."""
    app = dash.Dash(
        __name__,
        external_stylesheets=[
            dbc.themes.DARKLY,  # Bootstrap dark theme
            # Custom CSS in assets/ folder is automatically loaded by Dash
        ],
        suppress_callback_exceptions=True,
        title="DeepSeek Trading Dashboard",
        update_title=None  # Disable "Updating..." in title
    )

    # Configure metadata for better SEO and mobile experience
    app.index_string = '''
    <!DOCTYPE html>
    <html>
        <head>
            {%metas%}
            <title>{%title%}</title>
            {%favicon%}
            {%css%}
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta name="description" content="Professional AI-powered trading dashboard with real-time analysis">
            <link rel="preconnect" href="https://fonts.googleapis.com">
            <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
            <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
        </head>
        <body>
            {%app_entry%}
            <footer>
                {%config%}
                {%scripts%}
                {%renderer%}
            </footer>
        </body>
    </html>
    '''

    app.layout = layout
    return app
