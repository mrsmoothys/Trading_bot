"""
Trading Dashboard - Fully Functional
Web-based dashboard with interactive charts, timeframe selection, and feature overlays.
"""

import asyncio
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import dash
from dash import dcc, html, Input, Output, State, callback, callback_context
from dash.exceptions import PreventUpdate
import dash_bootstrap_components as dbc
import pandas as pd
import numpy as np
from datetime import datetime, timedelta, timezone
from typing import Dict, Any, Tuple, Optional, List
from loguru import logger
import os
import time
import requests
import json

# Global state for tracking selections
GLOBAL_STATE = {
    'selected_timeframe': '15m',
    'selected_symbol': 'BTCUSDT',
    'active_features': {
        'liquidity': True,
        'supertrend': True,
        'chandelier': True,
        'orderflow': True,
        'regime': True,
        'alignment': False
    }
}

DATA_CACHE: Dict[Tuple[str, str, int], Dict[str, Any]] = {}
CACHE_TTL_SECONDS = int(os.getenv('DASH_DATA_CACHE_TTL', '30'))
USE_SAMPLE_DATA = os.getenv('DASH_USE_SAMPLE_DATA', '0') == '1'  # Default to live data

LAST_TOGGLE = {'ts': 0.0}
REGIME_FEATURE_STRATEGY = {
    "TRENDING_HIGH_VOL": ["supertrend", "chandelier"],
    "TRENDING_LOW_VOL": ["supertrend"],
    "RANGING_COMPRESSION": ["liquidity", "orderflow"],
    "RANGING_EXPANSION": ["liquidity", "orderflow", "regime"],
    "TRANSITION": ["orderflow"],
}

CHAT_CLIENT = None
CHAT_SYSTEM_CONTEXT = None
CHAT_INIT_ERROR = None
LIVE_REFRESH_MIN = int(os.getenv('DASH_LIVE_REFRESH_MIN', '5'))  # minutes between forced live pulls

def set_system_context(context):
    """Set the global system context."""
    global CHAT_SYSTEM_CONTEXT
    CHAT_SYSTEM_CONTEXT = context


def ensure_utc_timestamp(value) -> pd.Timestamp:
    """Convert timestamps to UTC-aware pandas Timestamp."""
    ts = pd.to_datetime(value)
    if ts.tzinfo is None or ts.tzinfo.utcoffset(ts) is None:
        return ts.tz_localize('UTC')
    return ts.tz_convert('UTC')


def run_async_task(async_func, *args, **kwargs):
    """Execute an async callable from sync contexts with graceful fallback."""
    try:
        return asyncio.run(async_func(*args, **kwargs))
    except RuntimeError as exc:
        # Happens if another loop is already running
        if "asyncio.run()" in str(exc):
            loop = asyncio.new_event_loop()
            try:
                asyncio.set_event_loop(loop)
                return loop.run_until_complete(async_func(*args, **kwargs))
            finally:
                asyncio.set_event_loop(None)
                loop.close()
        raise


def initialize_chat_client():
    """Lazy-load DeepSeek chat client for dashboard interactions."""
    global CHAT_CLIENT, CHAT_SYSTEM_CONTEXT, CHAT_INIT_ERROR

    if CHAT_CLIENT or CHAT_INIT_ERROR:
        return CHAT_CLIENT

    try:
        from core.system_context import SystemContext
        CHAT_SYSTEM_CONTEXT = SystemContext()

        # Memory manager is optional for chat context optimization
        memory_manager = None
        try:
            from core.memory_manager import M1MemoryManager
            memory_manager = M1MemoryManager()
        except Exception as mem_err:
            logger.warning(f"Memory manager unavailable for chat context: {mem_err}")

        from deepseek.client import DeepSeekBrain
        CHAT_CLIENT = DeepSeekBrain(CHAT_SYSTEM_CONTEXT, memory_manager)
        logger.info("DeepSeek chat client initialized for dashboard")
    except Exception as exc:
        CHAT_INIT_ERROR = str(exc)
        CHAT_CLIENT = None
        logger.warning(f"DeepSeek AI chat unavailable: {exc}")

    return CHAT_CLIENT


def update_overlay_context(features: Dict[str, bool], timeframe: str):
    """Keep SystemContext overlay metadata in sync for richer chat context."""
    if not CHAT_SYSTEM_CONTEXT:
        return

    CHAT_SYSTEM_CONTEXT.overlay_state.update(features)
    CHAT_SYSTEM_CONTEXT.overlay_history.append({
        'timestamp': datetime.now().isoformat(),
        'timeframe': timeframe,
        'features': features.copy()
    })

    # Limit history to avoid unbounded growth
    if len(CHAT_SYSTEM_CONTEXT.overlay_history) > 50:
        CHAT_SYSTEM_CONTEXT.overlay_history = CHAT_SYSTEM_CONTEXT.overlay_history[-50:]


def gather_multi_timeframe_data(symbol: str, num_bars: int = 100) -> Dict[str, Any]:
    """Gather summarized data for multiple timeframes."""
    timeframes = ['1m', '5m', '15m', '1h', '4h', '1d']
    multi_tf_data = {}

    for tf in timeframes:
        try:
            # Fetch data for each timeframe
            df, meta = fetch_market_data(symbol, tf, num_bars=num_bars, force_refresh=False)

            if df is not None and len(df) > 0:
                # Calculate trend (simple slope of closing prices)
                recent_prices = df['close'].tail(20)
                trend_slope = (recent_prices.iloc[-1] - recent_prices.iloc[0]) / recent_prices.iloc[0] if len(recent_prices) > 1 else 0

                # Determine trend direction
                if trend_slope > 0.01:
                    trend = "BULLISH"
                elif trend_slope < -0.01:
                    trend = "BEARISH"
                else:
                    trend = "SIDEWAYS"

                # Calculate regime (simplified)
                returns = df['close'].pct_change()
                realized_vol = returns.rolling(20).std().fillna(0).iloc[-1] if len(df) > 20 else 0
                vol_threshold = returns.std() if len(returns) > 20 else 0

                if realized_vol > vol_threshold * 1.2:
                    regime = "HIGH_VOL"
                elif realized_vol < vol_threshold * 0.8:
                    regime = "LOW_VOL"
                else:
                    regime = "NORMAL_VOL"

                # Get current price level
                current_price = df['close'].iloc[-1]
                price_24h = df['close'].iloc[-25] if len(df) > 25 else df['close'].iloc[0]
                price_change_24h = ((current_price - price_24h) / price_24h) * 100 if price_24h != 0 else 0

                multi_tf_data[tf] = {
                    "trend": trend,
                    "regime": regime,
                    "current_price": round(current_price, 2),
                    "price_change_24h": round(price_change_24h, 2),
                    "volatility": round(realized_vol * 100, 2),
                    "bars_analyzed": len(df)
                }
            else:
                multi_tf_data[tf] = {
                    "trend": "UNKNOWN",
                    "regime": "UNKNOWN",
                    "current_price": 0,
                    "price_change_24h": 0,
                    "volatility": 0,
                    "bars_analyzed": 0
                }

        except Exception as e:
            logger.warning(f"Failed to fetch data for {tf}: {e}")
            multi_tf_data[tf] = {
                "trend": "ERROR",
                "regime": "ERROR",
                "current_price": 0,
                "price_change_24h": 0,
                "volatility": 0,
                "bars_analyzed": 0,
                "error": str(e)
            }

    return multi_tf_data


def build_chat_context(
    message_type: str = "strategy",
    chat_history: Optional[List[Dict[str, Any]]] = None
) -> Dict[str, Any]:
    """Create context payload for DeepSeek chat responses with multi-timeframe data."""
    current_tf = GLOBAL_STATE.get('selected_timeframe', '15m')
    symbol = GLOBAL_STATE.get('selected_symbol', 'BTCUSDT')
    logger.info(f"[DIAGNOSTIC] build_chat_context called - Using timeframe: {current_tf}, Message type: {message_type}")

    # Gather multi-timeframe data
    multi_tf_data = gather_multi_timeframe_data(symbol)

    conversation_history: List[Dict[str, Any]] = []
    if chat_history:
        for msg in chat_history[-10:]:
            conversation_history.append({
                "role": "user" if msg.get('is_user', True) else "assistant",
                "text": msg.get('text', ''),
                "timestamp": msg.get('timestamp', '')
            })

    context = {
        "message_type": message_type,
        "dashboard_state": {
            "symbol": symbol,
            "timeframe": current_tf,
            "active_features": GLOBAL_STATE['active_features'],
            "timestamp": datetime.now().isoformat(),
            "multi_timeframe_summary": multi_tf_data
        }
    }

    if conversation_history:
        context["conversation_history"] = conversation_history

    if CHAT_SYSTEM_CONTEXT:
        context["system_state"] = CHAT_SYSTEM_CONTEXT.get_context_for_deepseek()

    logger.info(f"[DIAGNOSTIC] Chat context payload timeframe: {context['dashboard_state']['timeframe']} with {len(multi_tf_data)} timeframe summaries")
    return context


def create_feature_metrics_table(
    metrics: Dict[str, Dict[str, Any]],
    current_regime: str = "UNKNOWN",
    recommendations: List[str] = None
) -> html.Div:
    """Render telemetry table for feature latency/memory usage."""
    if not metrics:
        return html.Div(
            "Telemetry pending â€” run the trading loop to capture feature metrics.",
            style={'color': '#666', 'fontStyle': 'italic', 'padding': '10px'}
        )

    header = html.Tr([
        html.Th("Feature"),
        html.Th("Latency (ms)"),
        html.Th("Memory Î” (MB)"),
        html.Th("Timestamp")
    ])
    rows = []
    for name, data in metrics.items():
        rows.append(html.Tr([
            html.Td(name.title()),
            html.Td(f"{data.get('latency_ms', 0):.2f}"),
            html.Td(f"{data.get('memory_delta_mb', 0):.2f}"),
            html.Td(data.get('timestamp', '').split('T')[0])
        ]))

    table = html.Table([header] + rows, style={
        'width': '100%',
        'borderCollapse': 'collapse',
        'fontSize': '13px'
    })
    overlay_text = ', '.join(recommendations) if recommendations else 'None'
    extra = html.P(
        f"Current regime: {current_regime} | Recommended overlays: {overlay_text}",
        style={'color': '#666', 'fontSize': '12px', 'marginTop': '10px'}
    )
    return html.Div([table, extra])


def call_deepseek_chat(
    user_message: str,
    message_type: str = "strategy",
    chat_history: Optional[List[Dict[str, Any]]] = None
) -> Tuple[str, str]:
    """
    Invoke DeepSeek chat interface and return (response text, status label).
    Falls back to informative message when AI isn't available.
    """
    chat_client = initialize_chat_client()

    if not chat_client:
        return generate_demo_chat_response(user_message, message_type, CHAT_INIT_ERROR)

    try:
        context = build_chat_context(message_type, chat_history)
        response = run_async_task(
            chat_client.chat_interface,
            user_message,
            context,
            message_type
        )
        if isinstance(response, str) and not response.lower().startswith("sorry, i encountered an error"):
            return response, "DeepSeek AI response âœ“"

        logger.warning(f"DeepSeek returned error payload, switching to demo response: {response}")
        return generate_demo_chat_response(user_message, message_type, "DeepSeek API error")
    except Exception as exc:
        error_msg = f"DeepSeek AI error: {exc}"
        logger.error(error_msg)
        return generate_demo_chat_response(user_message, message_type, str(exc))


def generate_demo_chat_response(message_text: str, message_type: str, reason: Optional[str] = None) -> Tuple[str, str]:
    """Build a helpful fallback response when DeepSeek is unavailable."""
    status_reason = reason or CHAT_INIT_ERROR or "DeepSeek configuration missing"
    symbol = GLOBAL_STATE.get('selected_symbol', 'BTCUSDT')
    timeframe = GLOBAL_STATE.get('selected_timeframe', '15m')
    features = [name for name, enabled in GLOBAL_STATE.get('active_features', {}).items() if enabled]

    summary = [
        f"DeepSeek AI is currently unavailable ({status_reason}).",
        "This is a demo response so you can keep testing the UI.",
        "",
        f"- Symbol: {symbol}",
        f"- Timeframe: {timeframe}",
        f"- Active overlays: {', '.join(features) if features else 'none'}",
        "",
        "Requested message:",
        message_text
    ]

    if CHAT_SYSTEM_CONTEXT:
        perf = CHAT_SYSTEM_CONTEXT.get_performance_summary()
        summary.extend([
            "",
            "Recent system state:",
            f"â€¢ Total trades: {perf.get('total_trades', 0)}",
            f"â€¢ Win rate: {perf.get('win_rate', 0):.2%}",
            f"â€¢ Max drawdown: {perf.get('max_drawdown', 0):.2%}"
        ])

    return "\n".join(summary), "Demo response âœ“"


def render_chat_history(chat_history):
    """Convert chat history into Dash components."""
    components = []
    for msg in chat_history[-50:]:
        if msg.get('is_user', True):
            components.append(
                html.Div([
                    html.Div("You", style={'fontWeight': 'bold', 'marginBottom': '5px', 'color': '#00ff88'}),
                    html.Div(msg.get('text', ''), style={
                        'backgroundColor': '#1a1a1a',
                        'padding': '10px',
                        'borderRadius': '8px',
                        'maxWidth': '70%',
                        'marginLeft': 'auto'
                    }),
                    html.Div(msg.get('timestamp', ''), style={
                        'fontSize': '10px',
                        'color': '#666',
                        'marginTop': '5px',
                        'textAlign': 'right'
                    })
                ], style={'textAlign': 'right', 'marginBottom': '15px'})
            )
        else:
            components.append(
                html.Div([
                    html.Div("DeepSeek AI", style={'fontWeight': 'bold', 'marginBottom': '5px', 'color': '#4488ff'}),
                    html.Div(msg.get('text', ''), style={
                        'backgroundColor': '#1a1a1a',
                        'padding': '15px',
                        'borderRadius': '8px',
                        'maxWidth': '70%',
                        'borderLeft': '3px solid #4488ff'
                    }),
                    html.Div(msg.get('timestamp', ''), style={'fontSize': '10px', 'color': '#666', 'marginTop': '5px'})
                ], style={'marginBottom': '15px'})
            )

    return components


def process_chat_request(
    chat_history,
    message_text: str,
    message_type: str = "strategy",
    status_prefix: str = "Message sent"
):
    """Handle chat exchange with DeepSeek and return updated history + status."""
    chat_history = chat_history or []
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Log the chat request with current timeframe context
    current_tf = GLOBAL_STATE.get('selected_timeframe', 'UNKNOWN')
    logger.info(f"[DIAGNOSTIC] Processing chat request - Type: {message_type}, Timeframe in context: {current_tf}, Message: {message_text[:50]}...")

    user_message = {
        'is_user': True,
        'text': message_text,
        'timestamp': timestamp
    }
    # Chat history already stored in chat-history-store component

    # Pass current chat_history (before adding user/ai messages) to DeepSeek
    ai_text, ai_status = call_deepseek_chat(message_text, message_type, chat_history)
    ai_message = {
        'is_user': False,
        'text': ai_text,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    # Chat history already stored in chat-history-store component

    # Create updated history with both user and AI messages
    updated_history = chat_history + [user_message, ai_message]

    # Also update SystemContext conversation_memory for DeepSeek memory
    if CHAT_SYSTEM_CONTEXT:
        CHAT_SYSTEM_CONTEXT.add_conversation_message(
            user_message['text'],
            ai_text,
            message_type
        )

    status = f"{status_prefix}: {ai_status} | Logged to: logs/chat_history.log"
    logger.info(f"[DIAGNOSTIC] Chat response generated with timeframe context: {current_tf}")
    return updated_history, render_chat_history(updated_history), status


def parse_backtest_command(message_text: str) -> Optional[Dict[str, Any]]:
    """Parse natural language backtest command from chat.

    Examples:
    - "run backtest BTCUSDT 1h convergence"
    - "run backtest symbol=ETHUSDT timeframe=15m strategy=sma"
    - "backtest BTC on 4h with macd strategy"
    """
    import re

    message_lower = message_text.lower()

    # Check if this is a backtest command
    if not ('backtest' in message_lower or 'test strategy' in message_lower):
        return None

    config = {
        'symbol': 'BTCUSDT',  # defaults
        'timeframe': '1h',
        'strategy': 'convergence',
        'start': (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'),
        'end': datetime.now().strftime('%Y-%m-%d'),
        'initial_capital': 10000.0
    }

    # Extract symbol
    symbol_pattern = r'(BTCUSDT|ETHUSDT|SOLUSDT|BTC|ETH|SOL)'
    symbol_match = re.search(symbol_pattern, message_text, re.IGNORECASE)
    if symbol_match:
        sym = symbol_match.group(1).upper()
        if sym in ['BTC', 'ETH', 'SOL']:
            sym += 'USDT'
        config['symbol'] = sym

    # Extract timeframe
    tf_pattern = r'\b(1m|5m|15m|1h|4h|1d)\b'
    tf_match = re.search(tf_pattern, message_text, re.IGNORECASE)
    if tf_match:
        config['timeframe'] = tf_match.group(1).lower()

    # Extract strategy
    strategy_pattern = r'(convergence|sma|rsi|macd)'
    strategy_match = re.search(strategy_pattern, message_text, re.IGNORECASE)
    if strategy_match:
        config['strategy'] = strategy_match.group(1).lower()

    # Extract capital if specified
    capital_pattern = r'(?:capital|money|funds?)\s+(?:of\s+)?[$]?(\d+(?:,\d{3})*(?:\.\d+)?)'
    capital_match = re.search(capital_pattern, message_text, re.IGNORECASE)
    if capital_match:
        config['initial_capital'] = float(capital_match.group(1).replace(',', ''))

    return config


def call_backtest_api(config: Dict[str, Any]) -> Dict[str, Any]:
    """Call the backtest API endpoint."""
    try:
        response = requests.post(
            'http://localhost:8000/backtest',
            json=config,
            timeout=30
        )

        if response.status_code == 200:
            return response.json()
        else:
            return {
                'success': False,
                'error': f"API error: {response.status_code} - {response.text}"
            }
    except requests.exceptions.ConnectionError:
        return {
            'success': False,
            'error': "Cannot connect to backtest API. Make sure it's running on localhost:8000"
        }
    except Exception as e:
        return {
            'success': False,
            'error': f"Error calling backtest API: {str(e)}"
        }


def format_backtest_chat_response(config: Dict[str, Any], api_response: Dict[str, Any]) -> str:
    """Format backtest results for chat display."""
    if not api_response.get('success', False):
        error = api_response.get('error', 'Unknown error')
        return f"âŒ Backtest failed: {error}"

    result = api_response.get('result', {})

    # Format results as markdown
    response_lines = [
        f"âœ… Backtest completed for {config['symbol']} on {config['timeframe']} timeframe",
        f"Strategy: {config['strategy'].upper()}",
        f"Period: {config['start']} to {config['end']}",
        "",
        "**Results:**",
        f"â€¢ Total Return: {result.get('total_return_pct', 0):+.2f}%",
        f"â€¢ Sharpe Ratio: {result.get('sharpe_ratio', 0):.3f}",
        f"â€¢ Max Drawdown: {result.get('max_drawdown', 0):.2f}%",
        f"â€¢ Win Rate: {result.get('win_rate', 0):.1f}%",
        f"â€¢ Total Trades: {result.get('total_trades', 0)}",
        "",
        f"**Capital:**",
        f"â€¢ Initial: ${config['initial_capital']:,.2f}",
        f"â€¢ Final: ${result.get('final_capital', 0):,.2f}",
        f"â€¢ Profit Factor: {result.get('profit_factor', 0):.2f}",
        "",
        "ðŸ’¡ This backtest has been saved to the experiment database."
    ]

    if api_response.get('config_hash'):
        response_lines.append(f"Config hash: {api_response['config_hash'][:8]}...")

    return "\n".join(response_lines)


def process_chat_request(
    chat_history,
    message_text: str,
    message_type: str = "strategy",
    status_prefix: str = "Message sent"
):
    """Handle chat exchange with DeepSeek and return updated history + status."""
    chat_history = chat_history or []
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Log the chat request with current timeframe context
    current_tf = GLOBAL_STATE.get('selected_timeframe', 'UNKNOWN')
    logger.info(f"[DIAGNOSTIC] Processing chat request - Type: {message_type}, Timeframe in context: {current_tf}, Message: {message_text[:50]}...")

    user_message = {
        'is_user': True,
        'text': message_text,
        'timestamp': timestamp
    }
    # Chat history already stored in chat-history-store component

    # Pass current chat_history (before adding user/ai messages) to DeepSeek
    ai_text, ai_status = call_deepseek_chat(message_text, message_type, chat_history)
    ai_message = {
        'is_user': False,
        'text': ai_text,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    # Chat history already stored in chat-history-store component

    # Create updated history with both user and AI messages
    updated_history = chat_history + [user_message, ai_message]

    # Also update SystemContext conversation_memory for DeepSeek memory
    if CHAT_SYSTEM_CONTEXT:
        CHAT_SYSTEM_CONTEXT.add_conversation_message(
            user_message['text'],
            ai_text,
            message_type
        )

    status = f"{status_prefix}: {ai_status} | Logged to: logs/chat_history.log"
    logger.info(f"[DIAGNOSTIC] Chat response generated with timeframe context: {current_tf}")
    return updated_history, render_chat_history(updated_history), status

def generate_sample_data(symbol: str, timeframe: str, num_bars: int = 200) -> pd.DataFrame:
    """Generate realistic sample OHLCV data for testing."""
    # Set parameters based on symbol and timeframe
    base_price = {
        'BTCUSDT': 100000,
        'ETHUSDT': 3000,
        'SOLUSDT': 150
    }.get(symbol, 100000)

    # Time delta based on timeframe
    time_deltas = {
        '1m': timedelta(minutes=1),
        '5m': timedelta(minutes=5),
        '15m': timedelta(minutes=15),
        '1h': timedelta(hours=1),
        '4h': timedelta(hours=4),
        '1d': timedelta(days=1)
    }
    td = time_deltas.get(timeframe, timedelta(minutes=15))

    # Generate timestamps
    end_time = datetime.now()
    start_time = end_time - (num_bars * td)
    timestamps = pd.date_range(start=start_time, end=end_time, periods=num_bars)

    # Generate price data with random walk
    # IMPORTANT: Use stable seed based on symbol (NOT timeframe) for consistent price levels
    np.random.seed(42)  # Fixed seed for reproducible data
    returns = np.random.normal(0.001, 0.02, num_bars)  # Small positive drift with volatility
    prices = base_price * (1 + returns).cumprod()

    # Generate OHLC from close prices
    opens = prices.copy()
    highs = np.maximum(opens, prices) * (1 + np.abs(np.random.normal(0, 0.01, num_bars)))
    lows = np.minimum(opens, prices) * (1 - np.abs(np.random.normal(0, 0.01, num_bars)))
    closes = prices

    # Generate volume (higher volume on larger moves)
    price_changes = np.abs(np.diff(np.concatenate([[opens[0]], closes])))
    volumes = np.random.lognormal(4, 1, num_bars) * (1 + price_changes * 5)

    return pd.DataFrame({
        'timestamp': timestamps,
        'open': opens,
        'high': highs,
        'low': lows,
        'close': closes,
        'volume': volumes
    })


async def get_real_market_data(symbol: str, timeframe: str, num_bars: int = 200) -> Tuple[pd.DataFrame, bool]:
    """Fetch real market data from Binance demo API with DataStore caching.

    Returns:
        Tuple containing the dataframe and a flag indicating if sample data was used.
    """
    used_sample_data = False
    try:
        from core.data.binance_client import BinanceClient
        from core.data.data_store import DataStore

        # Initialize DataStore
        data_store = DataStore()

        # Create cache key
        cache_key = f"ohlcv:{symbol}:{timeframe}"

        # Try to get from DataStore first (with get_or_fetch pattern)
        async def fetch_data():
            client = BinanceClient()
            ohlcv_data = await client.get_ohlcv(symbol, timeframe, limit=num_bars)
            if ohlcv_data is not None and len(ohlcv_data) > 0:
                # Store in DataStore
                await data_store.store_ohlcv(symbol, timeframe, ohlcv_data)
                logger.info(f"Fetched {len(ohlcv_data)} bars from Binance and cached")
                return ohlcv_data
            return None

        # Use get_or_fetch to check cache and fetch if needed
        ohlcv_data = await data_store.get_or_fetch(cache_key, fetch_data, ttl=60)

        if ohlcv_data is not None and len(ohlcv_data) > 0:
            return ohlcv_data, used_sample_data
        else:
            logger.warning("Failed to fetch real data, falling back to sample data")

    except Exception as e:
        logger.error(f"Error fetching real market data: {e}")
        logger.info("Falling back to sample data")

    used_sample_data = True
    return generate_sample_data(symbol, timeframe, num_bars), used_sample_data


# Timeframe to minutes mapping for freshness checks
TF_MINUTES = {
    '1m': 1,
    '3m': 3,
    '5m': 5,
    '15m': 15,
    '30m': 30,
    '1h': 60,
    '2h': 120,
    '4h': 240,
    '6h': 360,
    '8h': 480,
    '12h': 720,
    '1d': 1440,
    '3d': 4320,
    '1w': 10080
}

def fetch_market_data(symbol: str, timeframe: str, num_bars: int = 200, force_refresh: bool = False) -> Tuple[pd.DataFrame, Dict[str, Any]]:
    """
    Retrieve market data with caching and freshness-aware fetching.

    Returns:
        Tuple of (dataframe, metadata dict)
    """
    key = (symbol, timeframe, num_bars)
    now = datetime.now()
    cached_entry = DATA_CACHE.get(key)
    last_live_pull = getattr(fetch_market_data, "_last_live_pull", {})

    # Always clear cache if force_refresh is True
    if force_refresh and cached_entry:
        logger.debug(f"Cache cleared for {symbol}-{timeframe}")
        DATA_CACHE.pop(key, None)
        cached_entry = None

    # Check in-memory cache first
    if cached_entry and not force_refresh:
        age = (now - cached_entry['timestamp']).total_seconds()
        if age < CACHE_TTL_SECONDS:
            logger.debug(
                f"Memory cache hit for {symbol}-{timeframe} ({age:.1f}s old)"
            )
            return cached_entry['df'].copy(), {
                'cache_hit': True,
                'used_sample_data': cached_entry['used_sample_data']
            }

    df = None
    used_sample_data = USE_SAMPLE_DATA

    # Try to get from DataStore if not using sample data only
    if not USE_SAMPLE_DATA:
        try:
            from core.data.data_store import DataStore

            # Get or create DataStore instance
            if not hasattr(fetch_market_data, '_datastore'):
                fetch_market_data._datastore = DataStore(cache_dir='data/cache')
                logger.info("DataStore initialized for dashboard")

            datastore = fetch_market_data._datastore

            # Try to get from DataStore cache or Parquet
            if force_refresh:
                df = datastore.get_historical_data(symbol, timeframe, force_refresh=True)
            else:
                df = datastore.get_historical_data(symbol, timeframe)

            # If we have data from DataStore, use it
            if df is not None and len(df) > 0:
                # Limit to requested number of bars
                df = df.tail(num_bars).reset_index(drop=True)

                # Check if data is stale (P1.1: Freshness detection)
                is_stale = False
                if not used_sample_data and len(df) > 0:
                    # Get last candle timestamp
                    last_timestamp = ensure_utc_timestamp(df['timestamp'].iloc[-1])
                    now_utc = datetime.now(timezone.utc)
                    age_delta = (now_utc - last_timestamp.to_pydatetime()).total_seconds() / 60  # Convert to minutes

                    # Get expected timeframe duration
                    tf_minutes = TF_MINUTES.get(timeframe, 60)
                    # Data is stale if it's older than 2x the timeframe (allowing for exchange delay)
                    stale_threshold = tf_minutes * 2
                    is_stale = age_delta > stale_threshold
                    needs_live_refresh = age_delta > LIVE_REFRESH_MIN
                    pulled_recently = False
                    if needs_live_refresh:
                        last_pull_ts = last_live_pull.get(key)
                        if last_pull_ts:
                            pulled_recently = (now - last_pull_ts).total_seconds() / 60 <= LIVE_REFRESH_MIN

                    logger.info(
                        f"Data freshness check: {symbol} {timeframe} - "
                        f"Last candle age: {age_delta:.1f}m, Stale threshold: {stale_threshold:.1f}m, "
                        f"Stale: {is_stale}, Live refresh needed: {needs_live_refresh and not pulled_recently}"
                    )

                    # If stale, force a fresh fetch from Binance
                    if (is_stale or (needs_live_refresh and not pulled_recently)) and not force_refresh:
                        logger.warning(
                            f"Data age {age_delta:.1f}m exceeds refresh policy "
                            f"(stale>{stale_threshold:.1f}m or live_refresh>{LIVE_REFRESH_MIN}m), "
                            f"refreshing {symbol} {timeframe} from Binance"
                        )
                        df, live_fetch_used_sample = run_async_task(
                            get_real_market_data,
                            symbol,
                            timeframe,
                            num_bars=num_bars
                        )
                        if df is not None and len(df) > 0:
                            df = df.tail(num_bars).reset_index(drop=True)
                            used_sample_data = live_fetch_used_sample
                            last_live_pull[key] = now
                            logger.info(
                                f"Refreshed {symbol} {timeframe} from Binance - "
                                f"Last candle: {pd.to_datetime(df['timestamp'].iloc[-1])}, "
                                f"Total candles: {len(df)}"
                            )
                            # Persist fresh data to DataStore
                            try:
                                run_async_task(
                                    datastore.store_ohlcv,
                                    symbol,
                                    timeframe,
                                    df
                                )
                                logger.info(f"Persisted fresh {symbol} {timeframe} data to DataStore")
                            except Exception as e:
                                logger.warning(f"Failed to persist fresh data to DataStore: {e}")

                logger.info(f"Loaded {len(df)} candles from DataStore for {symbol} {timeframe} (stale_check={is_stale})")
                used_sample_data = False
            else:
                # DataStore doesn't have data, fetch from Binance
                logger.info(f"No data in DataStore for {symbol} {timeframe}, fetching from Binance")
                df, live_fetch_used_sample = run_async_task(
                    get_real_market_data,
                    symbol,
                    timeframe,
                    num_bars=num_bars
                )
                used_sample_data = live_fetch_used_sample
                last_live_pull[key] = now
                # Persist fresh data to DataStore
                if df is not None and len(df) > 0 and not used_sample_data:
                    try:
                        run_async_task(
                            datastore.store_ohlcv,
                            symbol,
                            timeframe,
                            df
                        )
                        logger.info(f"Persisted initial {symbol} {timeframe} data to DataStore")
                    except Exception as e:
                        logger.warning(f"Failed to persist data to DataStore: {e}")

        except Exception as e:
            logger.warning(f"DataStore/Binance fetch failed, using sample data: {e}")
            df = None
            used_sample_data = True
    else:
        logger.debug("DASH_USE_SAMPLE_DATA enabled - skipping real API calls")

    # Fallback to sample data if needed
    if df is None:
        logger.info(f"Using sample data for {symbol} {timeframe}")
        df = generate_sample_data(symbol, timeframe, num_bars=num_bars)
        used_sample_data = True

    # Update in-memory cache
    DATA_CACHE[key] = {
        'df': df.copy(),
        'timestamp': now,
        'used_sample_data': used_sample_data,
        'freshness_checked': True,
        'is_stale': is_stale if 'is_stale' in locals() else False
    }
    fetch_market_data._last_live_pull = last_live_pull

    # Calculate last candle age for metadata
    last_candle_age_min = 0
    if df is not None and len(df) > 0:
        last_timestamp = ensure_utc_timestamp(df['timestamp'].iloc[-1])
        last_candle_age_min = (datetime.now(timezone.utc) - last_timestamp.to_pydatetime()).total_seconds() / 60

    logger.debug(
        f"Returning data for {symbol}-{timeframe}: {len(df)} candles, "
        f"sample_data={used_sample_data}, cache_hit=False, last_age={last_candle_age_min:.1f}m"
    )
    return df.copy(), {
        'cache_hit': False,
        'used_sample_data': used_sample_data,
        'last_candle_age_min': last_candle_age_min,
        'is_stale': is_stale if 'is_stale' in locals() else False,
        'tf_minutes': TF_MINUTES.get(timeframe, 60)
    }


def calculate_supertrend(df: pd.DataFrame, period: int = 10, multiplier: float = 3.0) -> Dict[str, Any]:
    """Calculate Supertrend indicator."""
    close = df['close']
    high = df['high']
    low = df['low']

    # Calculate ATR
    tr1 = high - low
    tr2 = abs(high - close.shift())
    tr3 = abs(low - close.shift())
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(period).mean()

    # Calculate HL2
    hl2 = (high + low) / 2

    # Calculate Upper and Lower bands
    upper_band = hl2 + (multiplier * atr)
    lower_band = hl2 - (multiplier * atr)

    # Calculate Supertrend
    supertrend = pd.Series(index=df.index, dtype=float)
    direction = pd.Series(index=df.index, dtype=int)  # 1 for uptrend, -1 for downtrend

    supertrend.iloc[0] = upper_band.iloc[0]
    direction.iloc[0] = 1

    for i in range(1, len(df)):
        if close.iloc[i] > supertrend.iloc[i-1]:
            direction.iloc[i] = 1
            supertrend.iloc[i] = max(lower_band.iloc[i], supertrend.iloc[i-1])
        else:
            direction.iloc[i] = -1
            supertrend.iloc[i] = min(upper_band.iloc[i], supertrend.iloc[i-1])

    return {
        'supertrend': supertrend,
        'direction': direction,
        'atr': atr
    }


def calculate_chandelier_exit(df: pd.DataFrame, period: int = 22, multiplier: float = 3.0) -> Dict[str, Any]:
    """Calculate Chandelier Exit indicator."""
    close = df['close']
    high = df['high']
    low = df['low']

    # Calculate ATR
    tr1 = high - low
    tr2 = abs(high - close.shift())
    tr3 = abs(low - close.shift())
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.rolling(period).mean()

    # Calculate Chandelier Exit
    long_exit = high.rolling(period).max() - (multiplier * atr)
    short_exit = low.rolling(period).min() + (multiplier * atr)

    return {
        'long_exit': long_exit,
        'short_exit': short_exit,
        'atr': atr
    }


def calculate_liquidity_zones(df: pd.DataFrame, lookback: int = 100) -> Dict[str, Any]:
    """Calculate liquidity zones (areas of high volume)."""
    typical_price = (df['high'] + df['low'] + df['close']) / 3
    volume = df['volume']

    # Create price bins
    price_min = df['low'].min()
    price_max = df['high'].max()
    price_bins = np.linspace(price_min, price_max, 20)

    volume_at_price = np.zeros(len(price_bins) - 1)

    # Aggregate volume at each price level
    for i, row in df.iterrows():
        low = row['low']
        high = row['high']
        vol = row['volume']

        for j in range(len(price_bins) - 1):
            bin_low = price_bins[j]
            bin_high = price_bins[j + 1]
            if high < bin_low or low > bin_high:
                continue
            # Prevent division by zero for flat candles (high == low)
            price_range = high - low
            if price_range <= 0:
                continue
            overlap = (min(high, bin_high) - max(low, bin_low)) / price_range
            volume_at_price[j] += vol * overlap

    # Find significant zones (top 20% of volume)
    threshold = np.percentile(volume_at_price, 80)
    significant_zones = price_bins[:-1][volume_at_price > threshold]

    return {
        'zones': significant_zones,
        'volume_profile': dict(zip(price_bins[:-1], volume_at_price))
    }


def calculate_market_regime_overlay(df: pd.DataFrame, short_window: int = 20,
                                    long_window: int = 60) -> Dict[str, Any] | None:
    """Classify market regime for shading overlays."""
    if len(df) < long_window:
        return None

    returns = df['close'].pct_change()
    realized_vol = returns.rolling(long_window).std().fillna(0)
    vol_threshold = realized_vol.median()
    sma_short = df['close'].rolling(short_window).mean()
    sma_long = df['close'].rolling(long_window).mean()
    trend_strength = (sma_short - sma_long).fillna(0)

    regime_series = pd.Series('RANGING_LOW_VOL', index=df.index)
    regime_series[(trend_strength > 0) & (realized_vol >= vol_threshold)] = 'TRENDING_UP_HIGH_VOL'
    regime_series[(trend_strength > 0) & (realized_vol < vol_threshold)] = 'TRENDING_UP_LOW_VOL'
    regime_series[(trend_strength < 0) & (realized_vol >= vol_threshold)] = 'TRENDING_DOWN_HIGH_VOL'
    regime_series[(trend_strength < 0) & (realized_vol < vol_threshold)] = 'TRENDING_DOWN_LOW_VOL'

    colors = {
        'TRENDING_UP_HIGH_VOL': 'rgba(0, 255, 136, 0.08)',
        'TRENDING_UP_LOW_VOL': 'rgba(0, 136, 255, 0.08)',
        'TRENDING_DOWN_HIGH_VOL': 'rgba(255, 68, 68, 0.12)',
        'TRENDING_DOWN_LOW_VOL': 'rgba(255, 165, 0, 0.1)',
        'RANGING_LOW_VOL': 'rgba(255, 255, 255, 0.03)'
    }

    return {
        'series': regime_series,
        'colors': colors
    }


def calculate_timeframe_alignment(df: pd.DataFrame) -> Dict[str, pd.Series] | None:
    """Compute multi-EMA alignment signals for overlay markers."""
    if len(df) < 55:
        return None

    ema_fast = df['close'].ewm(span=10, adjust=False).mean()
    ema_mid = df['close'].ewm(span=21, adjust=False).mean()
    ema_slow = df['close'].ewm(span=55, adjust=False).mean()

    bullish = (ema_fast > ema_mid) & (ema_mid > ema_slow)
    bearish = (ema_fast < ema_mid) & (ema_mid < ema_slow)

    return {
        'bullish': bullish.fillna(False),
        'bearish': bearish.fillna(False)
    }


def create_interactive_chart(df: pd.DataFrame, symbol: str, timeframe: str,
                            features: Dict[str, Any]) -> go.Figure:
    """Create an interactive TradingView-style chart with feature overlays."""
    show_order_flow = features.get('orderflow', True)
    orderflow_height = 0.15 if show_order_flow else 0.01
    orderflow_title = 'Order Flow Imbalance' if show_order_flow else 'Order Flow (disabled)'

    # Create subplots
    fig = make_subplots(
        rows=3,
        cols=1,
        shared_xaxes=True,
        vertical_spacing=0.02,
        row_heights=[0.7, 0.15, orderflow_height],
        subplot_titles=(
            f'{symbol} - {timeframe.upper()} Timeframe',
            'Volume',
            orderflow_title
        )
    )

    # Add candlestick chart
    fig.add_trace(
        go.Candlestick(
            x=df['timestamp'],
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close'],
            name=symbol,
            increasing_line_color='#00ff88',
            decreasing_line_color='#ff4444',
            increasing_fillcolor='#00ff88',
            decreasing_fillcolor='#ff4444',
            line=dict(width=1)
        ),
        row=1, col=1
    )

    # Add Supertrend if enabled
    if features.get('supertrend', False):
        st_data = calculate_supertrend(df)
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=st_data['supertrend'],
                name='Supertrend',
                line=dict(color='#4488ff', width=2, dash='solid'),
                opacity=0.8
            ),
            row=1, col=1
        )

    # Add Chandelier Exit if enabled
    if features.get('chandelier', False):
        ce_data = calculate_chandelier_exit(df)
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=ce_data['long_exit'],
                name='Chandelier Long',
                line=dict(color='#ff9900', width=1, dash='dash'),
                opacity=0.7
            ),
            row=1, col=1
        )
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=ce_data['short_exit'],
                name='Chandelier Short',
                line=dict(color='#ff9900', width=1, dash='dash'),
                opacity=0.7
            ),
            row=1, col=1
        )

    # Add Liquidity Zones if enabled
    if features.get('liquidity', False):
        lz_data = calculate_liquidity_zones(df)
        zones = lz_data.get('zones', [])

        if len(zones) > 0:
            logger.debug(f"Drawing {len(zones)} liquidity zones")

            # Draw horizontal lines for each liquidity zone
            for zone in zones:
                fig.add_hline(
                    y=zone,
                    line=dict(color='rgba(255, 215, 0, 0.8)', width=2, dash='dash'),
                    layer='above',
                    annotation_text=f"Liquidity Zone: {zone:.2f}",
                    annotation_position="top left",
                    annotation=dict(font_size=10, font_color='rgba(255, 215, 0, 0.9)')
                )

            # Draw rectangular shading for each zone (wider for better visibility)
            for zone in zones:
                fig.add_vrect(
                    x0=df['timestamp'].iloc[0],
                    x1=df['timestamp'].iloc[-1],
                    y0=zone * 0.99,
                    y1=zone * 1.01,
                    fillcolor='rgba(255, 215, 0, 0.15)',
                    line_width=1,
                    line_color='rgba(255, 215, 0, 0.4)',
                    layer='below'
                )
        else:
            logger.debug("No significant liquidity zones detected")

    # Add market regime shading
    if features.get('regime', False):
        regime_data = calculate_market_regime_overlay(df)
        if regime_data:
            timestamps = df['timestamp']
            regimes = regime_data['series']
            colors = regime_data['colors']
            current_regime = regimes.iloc[0]
            segment_start = timestamps.iloc[0]

            for idx in range(1, len(timestamps)):
                if regimes.iloc[idx] != current_regime:
                    fig.add_vrect(
                        x0=segment_start,
                        x1=timestamps.iloc[idx],
                        fillcolor=colors.get(current_regime, 'rgba(255,255,255,0.03)'),
                        line_width=0,
                        layer='below'
                    )
                    current_regime = regimes.iloc[idx]
                    segment_start = timestamps.iloc[idx]

            # Add final segment
            fig.add_vrect(
                x0=segment_start,
                x1=timestamps.iloc[-1],
                fillcolor=colors.get(current_regime, 'rgba(255,255,255,0.03)'),
                line_width=0,
                layer='below'
            )

            last_regime_raw = regimes.iloc[-1]
            latest_regime = last_regime_raw.replace('_', ' ').title()
            regime_font_color = '#00ff88' if 'UP' in last_regime_raw else (
                '#ff4444' if 'DOWN' in last_regime_raw else '#f0e68c'
            )
            fig.add_annotation(
                text=f"Regime: {latest_regime}",
                xref='paper',
                yref='paper',
                x=0.01,
                y=0.98,
                bgcolor='rgba(0,0,0,0.5)',
                font={'color': regime_font_color, 'size': 12},
                showarrow=False
            )

    # Add timeframe alignment markers
    if features.get('alignment', False):
        alignment = calculate_timeframe_alignment(df)
        if alignment:
            bullish_idx = alignment['bullish']
            bearish_idx = alignment['bearish']

            if bullish_idx.any():
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'][bullish_idx],
                        y=df['close'][bullish_idx],
                        mode='markers',
                        marker=dict(
                            symbol='triangle-up',
                            color='#00ff88',
                            size=8,
                            line=dict(color='#0a0a0a', width=1)
                        ),
                        name='TF Alignment (Bullish)',
                        hovertemplate='Bullish alignment<br>%{x|%Y-%m-%d %H:%M}'
                    ),
                    row=1, col=1
                )

            if bearish_idx.any():
                fig.add_trace(
                    go.Scatter(
                        x=df['timestamp'][bearish_idx],
                        y=df['close'][bearish_idx],
                        mode='markers',
                        marker=dict(
                            symbol='triangle-down',
                            color='#ff4444',
                            size=8,
                            line=dict(color='#0a0a0a', width=1)
                        ),
                        name='TF Alignment (Bearish)',
                        hovertemplate='Bearish alignment<br>%{x|%Y-%m-%d %H:%M}'
                    ),
                    row=1, col=1
                )

    # Add Volume
    colors = ['#00ff88' if close >= open else '#ff4444'
              for close, open in zip(df['close'], df['open'])]
    fig.add_trace(
        go.Bar(
            x=df['timestamp'],
            y=df['volume'],
            name='Volume',
            marker_color=colors,
            opacity=0.6,
            yaxis='y2'
        ),
        row=2, col=1
    )

    # Add Order Flow
    if show_order_flow:
        df['body'] = abs(df['close'] - df['open'])
        df['upper_wick'] = df['high'] - df[['open', 'close']].max(axis=1)
        df['lower_wick'] = df[['open', 'close']].min(axis=1) - df['low']

        buying_pressure = (df['close'] > df['open']).astype(int)
        selling_pressure = (df['upper_wick'] > df['body'] * 1.5).astype(int)
        order_flow = buying_pressure - selling_pressure

        fig.add_trace(
            go.Bar(
                x=df['timestamp'],
                y=order_flow,
                name='Order Flow',
                marker_color=[
                    'rgba(0, 255, 0, 0.7)' if x > 0 else 'rgba(255, 0, 0, 0.7)'
                    for x in order_flow
                ],
                yaxis='y4'
            ),
            row=3, col=1
        )
    else:
        fig.update_yaxes(visible=False, row=3, col=1)
        fig.update_xaxes(showticklabels=False, row=3, col=1)

    # Update layout
    fig.update_layout(
        title=dict(
            text=f'<b>{symbol} Price Chart - {timeframe.upper()} Timeframe</b>',
            x=0.5,
            font=dict(size=20, color='white')
        ),
        height=800,
        showlegend=True,
        template='plotly_dark',
        xaxis_rangeslider_visible=False,
        paper_bgcolor='#0a0a0a',
        plot_bgcolor='#0a0a0a',
        font=dict(color='#ddd', size=11),
        dragmode='pan',
        hovermode='x unified',
        hoverdistance=50,
        spikedistance=1000,
        uirevision=f"{symbol}-{timeframe}",
        legend=dict(
            bgcolor='rgba(0,0,0,0.5)',
            bordercolor='rgba(255,255,255,0.2)',
            borderwidth=1
        ),
        margin=dict(l=50, r=50, t=80, b=50)
    )

    # Update axes
    fig.update_yaxes(
        title_text="Price (USDT)",
        row=1,
        col=1,
        gridcolor='#333',
        automargin=True,
        side='right',
        fixedrange=False,
        showspikes=True,
        spikemode='across',
        spikecolor='#00ff88',
        spikethickness=1
    )
    fig.update_yaxes(
        title_text="Volume",
        row=2,
        col=1,
        gridcolor='#333',
        automargin=True,
        fixedrange=False,
        showspikes=True,
        spikemode='across',
        spikecolor='#00ff88',
        spikethickness=1
    )
    fig.update_yaxes(
        title_text="Order Flow" if show_order_flow else "",
        row=3,
        col=1,
        gridcolor='#333',
        showticklabels=show_order_flow,
        automargin=True,
        fixedrange=False,
        showspikes=True,
        spikemode='across',
        spikecolor='#00ff88',
        spikethickness=1
    )
    fig.update_xaxes(
        title_text="Time",
        row=3,
        col=1,
        gridcolor='#333',
        showticklabels=show_order_flow,
        showspikes=True,
        spikemode='across',
        spikecolor='#00ff88',
        spikethickness=1
    )

    # Add range selector with buttons for different time periods
    fig.update_xaxes(
        rangeslider=dict(
            visible=True,
            thickness=0.05,
            bgcolor='rgba(255, 255, 255, 0.05)',
            bordercolor='rgba(255, 255, 255, 0.1)',
            borderwidth=1
        ),
        rangeselector=dict(
            buttons=list([
                dict(count=50, label="50", step="all", stepmode="backward"),
                dict(count=100, label="100", step="all", stepmode="backward"),
                dict(count=200, label="200", step="all", stepmode="backward"),
                dict(step="all", label="All")
            ]),
            bgcolor='rgba(26, 26, 26, 0.9)',
            bordercolor='rgba(255, 255, 255, 0.2)',
            borderwidth=1,
            font=dict(color='#ddd', size=11)
        )
    )

    # Add signal annotations (LONG/SHORT markers based on order flow)
    if show_order_flow:
        # Generate sample trading signals based on order flow
        order_flow_threshold = 0.3
        long_signals = []
        short_signals = []

        for i in range(10, len(df) - 10):
            # Look for strong buying pressure followed by confirmation
            if i < len(order_flow):
                # LONG signal: positive order flow with price confirmation
                if (order_flow.iloc[i] > order_flow_threshold and
                    df['close'].iloc[i] > df['close'].iloc[i-5]):
                    long_signals.append({
                        'index': i,
                        'timestamp': df['timestamp'].iloc[i],
                        'price': df['high'].iloc[i] * 1.01,
                        'text': 'LONG'
                    })

                # SHORT signal: negative order flow with price confirmation
                elif (order_flow.iloc[i] < -order_flow_threshold and
                      df['close'].iloc[i] < df['close'].iloc[i-5]):
                    short_signals.append({
                        'index': i,
                        'timestamp': df['timestamp'].iloc[i],
                        'price': df['low'].iloc[i] * 0.99,
                        'text': 'SHORT'
                    })

        # Add LONG signal annotations
        for signal in long_signals[-5:]:  # Show last 5 signals
            fig.add_annotation(
                x=signal['timestamp'],
                y=signal['price'],
                text="<b>LONG</b>",
                showarrow=True,
                arrowhead=2,
                arrowcolor='#00ff88',
                arrowwidth=2,
                arrowsize=1,
                ax=0,
                ay=-40,
                bgcolor='rgba(0, 255, 136, 0.9)',
                bordercolor='#00ff88',
                borderwidth=1,
                borderpad=4,
                font=dict(color='#000', size=10, family='Arial Black')
            )

        # Add SHORT signal annotations
        for signal in short_signals[-5:]:  # Show last 5 signals
            fig.add_annotation(
                x=signal['timestamp'],
                y=signal['price'],
                text="<b>SHORT</b>",
                showarrow=True,
                arrowhead=2,
                arrowcolor='#ff4444',
                arrowwidth=2,
                arrowsize=1,
                ax=0,
                ay=40,
                bgcolor='rgba(255, 68, 68, 0.9)',
                bordercolor='#ff4444',
                borderwidth=1,
                borderpad=4,
                font=dict(color='#fff', size=10, family='Arial Black')
            )

    return fig


def create_positions_table(active_positions: Dict[str, Any]) -> html.Table:
    """Create HTML table for active positions."""
    if not active_positions:
        return html.Div("No active positions", style={'color': '#888', 'padding': '20px', 'textAlign': 'center'})

    # Table styles
    table_style = {
        'width': '100%',
        'borderCollapse': 'collapse',
        'marginTop': '20px',
        'fontSize': '14px'
    }

    header_style = {
        'backgroundColor': '#1a1a1a',
        'color': '#00ff88',
        'padding': '12px',
        'textAlign': 'left',
        'borderBottom': '2px solid #00ff88'
    }

    cell_style = {
        'padding': '10px 12px',
        'borderBottom': '1px solid #333',
        'color': '#ddd'
    }

    # Create table header
    header = html.Tr([
        html.Th("Symbol", style=header_style),
        html.Th("Side", style=header_style),
        html.Th("Entry Price", style=header_style),
        html.Th("Current Price", style=header_style),
        html.Th("Size", style=header_style),
        html.Th("P&L", style=header_style),
        html.Th("P&L %", style=header_style),
        html.Th("Actions", style=header_style)
    ])

    # Create table rows
    rows = []
    for symbol, position in active_positions.items():
        pnl = position.get('unrealized_pnl', 0)
        pnl_percent = position.get('unrealized_pnl_percent', 0)

        pnl_color = '#00ff88' if pnl >= 0 else '#ff4444'

        row_style = {
            'backgroundColor': '#1a1a1a' if len(rows) % 2 == 0 else '#0f0f0f'
        }

        rows.append(html.Tr([
            html.Td(symbol, style={**cell_style, **row_style}),
            html.Td(position.get('side', 'N/A'), style={**cell_style, **row_style}),
            html.Td(f"${position.get('entry_price', 0):.2f}", style={**cell_style, **row_style}),
            html.Td(f"${position.get('current_price', 0):.2f}", style={**cell_style, **row_style}),
            html.Td(f"{position.get('quantity', 0):.4f}", style={**cell_style, **row_style}),
            html.Td(f"${pnl:.2f}", style={**cell_style, 'color': pnl_color, **row_style}),
            html.Td(f"{pnl_percent:.2f}%", style={**cell_style, 'color': pnl_color, **row_style}),
            html.Td(
                html.Button('Close', id=f'close-{symbol}', n_clicks=0, style={
                    'backgroundColor': '#ff4444',
                    'color': 'white',
                    'border': 'none',
                    'padding': '6px 12px',
                    'cursor': 'pointer',
                    'borderRadius': '4px',
                    'fontSize': '12px'
                }),
                style={**cell_style, **row_style}
            )
        ]))

    return html.Table([header] + rows, style=table_style)


def create_metrics_card(title: str, value: str, subtitle: str = "", color: str = "#00ff88") -> html.Div:
    """Create a metrics card."""
    return html.Div([
        html.H4(title, style={'margin': '0', 'color': '#888', 'fontSize': '14px', 'fontWeight': 'normal'}),
        html.H2(value, style={'margin': '5px 0', 'color': color, 'fontSize': '28px', 'fontWeight': 'bold'}),
        html.P(subtitle, style={'margin': '0', 'color': '#666', 'fontSize': '11px'})
    ], style={
        'backgroundColor': '#1a1a1a',
        'padding': '15px',
        'borderRadius': '8px',
        'border': f'2px solid {color}',
        'minHeight': '80px',
        'display': 'flex',
        'flexDirection': 'column',
        'justifyContent': 'center'
    })


def create_dashboard_app():
    """Create the Dash app with design system."""
    app = dash.Dash(
        __name__,
        external_stylesheets=[
            dbc.themes.DARKLY,  # Bootstrap dark theme
            # Custom CSS in assets/ folder is automatically loaded by Dash
        ],
        suppress_callback_exceptions=True,
        title="DeepSeek Trading Dashboard",
        update_title=None  # Disable "Updating..." in title
    )

    # Configure metadata for better SEO and mobile experience
    app.index_string = '''
    <!DOCTYPE html>
    <html>
        <head>
            {%metas%}
            <title>{%title%}</title>
            {%favicon%}
            {%css%}
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta name="description" content="Professional AI-powered trading dashboard with real-time analysis">
            <link rel="preconnect" href="https://fonts.googleapis.com">
            <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
            <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
            <style>
                :root {
                    --ds-bg: #0b0f17;
                    --ds-surface: #111827;
                    --ds-border: #1f2937;
                    --ds-accent: #22d3ee;
                    --ds-warn: #f59e0b;
                    --ds-good: #22c55e;
                    --ds-bad: #ef4444;
                    --ds-text: #e5e7eb;
                    --ds-muted: #9ca3af;
                }
                body {
                    margin: 0;
                    background: radial-gradient(circle at 20% 20%, rgba(34, 211, 238, 0.08), transparent 25%),
                                radial-gradient(circle at 80% 0%, rgba(124, 58, 237, 0.08), transparent 22%),
                                var(--ds-bg);
                    color: var(--ds-text);
                    font-family: 'Manrope', 'Inter', system-ui, -apple-system, sans-serif;
                }
                .ds-card {
                    background: var(--ds-surface);
                    border: 1px solid var(--ds-border);
                    border-radius: 14px;
                    padding: 18px;
                    box-shadow: 0 12px 28px rgba(0, 0, 0, 0.35);
                }
                .ds-card.mb-lg { margin-bottom: 18px; }
                .ds-metrics {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                    gap: 12px;
                }
                .ds-table table, .ds-table th, .ds-table td {
                    border: 1px solid var(--ds-border);
                    border-collapse: collapse;
                }
                .ds-table th, .ds-table td {
                    padding: 10px;
                    font-size: 13px;
                }
                .pill {
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                    padding: 6px 10px;
                    border-radius: 999px;
                    font-size: 12px;
                    font-weight: 700;
                    border: 1px solid var(--ds-border);
                    background: rgba(34,211,238,0.08);
                    color: var(--ds-text);
                }
                .pill.warn { background: rgba(245,158,11,0.12); border-color: rgba(245,158,11,0.4); }
                .pill.bad { background: rgba(239,68,68,0.12); border-color: rgba(239,68,68,0.4); }
                .pill.good { background: rgba(34,197,94,0.12); border-color: rgba(34,197,94,0.4); }
                .tf-btn {
                    background: transparent;
                    border: 1px solid var(--ds-border);
                    color: var(--ds-text);
                    border-radius: 10px;
                    padding: 10px 14px;
                    min-width: 52px;
                }
                .tf-btn:hover { border-color: var(--ds-accent); color: var(--ds-accent); }
                .action-row .btn {
                    border-radius: 10px;
                }
            </style>
        </head>
        <body>
            {%app_entry%}
            <footer>
                {%config%}
                {%scripts%}
                {%renderer%}
            </footer>
        </body>
    </html>
    '''

    # Define Layout
    layout = dbc.Container([
        # Header
        dbc.Row([
            dbc.Col([
                html.H1("DeepSeek Trading System", className="text-primary", style={'fontWeight': 'bold', 'fontSize': '24px'}),
                html.Div("Autonomous AI-Powered Trading", className="text-muted", style={'fontSize': '14px'}),
                # Status badges
                html.Div([
                    html.Span("LIVE", id="live-status-badge", className="badge bg-success me-2", style={'display': 'none'}),
                    html.Span("DEMO", id="demo-status-badge", className="badge bg-warning me-2"),
                    html.Span("Data Fresh: < 30s", id="freshness-badge", className="badge bg-info", style={'fontSize': '11px'}),
                ], className="mt-2")
            ], width=8),
            dbc.Col([
                html.Div(id='system-status-indicator', className="text-end")
            ], width=4)
        ], className="mb-4 mt-3 align-items-center"),

        # Main Tabs
        dbc.Tabs([
            # Tab 1: Market Analysis (Existing)
            dbc.Tab(label="Market Analysis", tab_id="tab-market", children=[
                dbc.Row([
                    # Left Column: Chart & Controls
                    dbc.Col([
                        dbc.Card([
                            dbc.CardBody([
                                # Toolbar
                                dbc.Row([
                                    dbc.Col([
                                        html.Div([
                                            html.Button("1m", id='tf-1m', n_clicks=0, className='tf-btn me-2'),
                                            html.Button("5m", id='tf-5m', n_clicks=0, className='tf-btn me-2'),
                                            html.Button("15m", id='tf-15m', n_clicks=0, className='tf-btn active me-2'),
                                            html.Button("1h", id='tf-1h', n_clicks=0, className='tf-btn me-2'),
                                            html.Button("4h", id='tf-4h', n_clicks=0, className='tf-btn me-2'),
                                            html.Button("1d", id='tf-1d', n_clicks=0, className='tf-btn'),
                                        ], className="d-flex")
                                    ], width=6),
                                    dbc.Col([
                                        html.Div([
                                            dbc.Checklist(
                                                options=[
                                                    {'label': 'Liquidity', 'value': 'liquidity'},
                                                    {'label': 'Order Flow', 'value': 'orderflow'},
                                                    {'label': 'Supertrend', 'value': 'supertrend'},
                                                    {'label': 'Chandelier', 'value': 'chandelier'},
                                                ],
                                                value=['liquidity', 'orderflow'],
                                                id='overlay-toggles',
                                                inline=True,
                                                switch=True,
                                            )
                                        ], className="d-flex justify-content-end")
                                    ], width=6)
                                ], className="mb-3"),

                                # Main Chart
                                dcc.Graph(
                                    id='main-chart',
                                    style={'height': '600px'},
                                    config={
                                        "scrollZoom": True,  # allow mouse wheel zoom
                                        "doubleClick": "reset",
                                        "displaylogo": False
                                    }
                                ),
                                
                                # Range Slider
                                html.Div([
                                    dcc.RangeSlider(
                                        id='chart-range-slider',
                                        min=0,
                                        max=100,
                                        step=1,
                                        value=[0, 100],
                                        marks=None,
                                        tooltip={"placement": "bottom", "always_visible": False}
                                    )
                                ], className="mt-3 px-2")
                            ])
                        ], className="ds-card mb-4"),
                    ], width=8),

                    # Right Column: Chat & Features
                    dbc.Col([
                        # Chat Interface
                        dbc.Card([
                            dbc.CardHeader("DeepSeek AI Assistant"),
                            dbc.CardBody([
                                html.Div(id='chat-history', style={'height': '400px', 'overflowY': 'auto', 'marginBottom': '10px'}),
                                dbc.InputGroup([
                                    dbc.Input(id='chat-input', placeholder="Ask about market structure...", type="text"),
                                    dbc.Button("Send", id='chat-send-btn', color="primary")
                                ]),
                                html.Div(id='debug-output', className="text-warning mt-2")
                            ])
                        ], className="ds-card mb-4"),

                        # Feature Metrics
                        dbc.Card([
                            dbc.CardHeader("Feature Health"),
                            dbc.CardBody(id='feature-metrics-content')
                        ], className="ds-card")
                    ], width=4)
                ])
            ]),

            # Tab 2: Account & Trading (New)
            dbc.Tab(label="Account & Trading", tab_id="tab-account", children=[
                dbc.Row([
                    # Portfolio Summary
                    dbc.Col([
                        dbc.Card([
                            dbc.CardBody([
                                html.H5("Portfolio Value", className="card-title text-muted"),
                                html.H2(id='portfolio-value', className="text-primary"),
                                html.Div(id='portfolio-pnl-percent')
                            ])
                        ], className="ds-card mb-3")
                    ], width=3),
                    dbc.Col([
                        dbc.Card([
                            dbc.CardBody([
                                html.H5("Unrealized PnL", className="card-title text-muted"),
                                html.H2(id='unrealized-pnl', className="text-success"),
                                html.Div("Active Positions Impact")
                            ])
                        ], className="ds-card mb-3")
                    ], width=3),
                    dbc.Col([
                        dbc.Card([
                            dbc.CardBody([
                                html.H5("Total Exposure", className="card-title text-muted"),
                                html.H2(id='total-exposure', className="text-warning"),
                                html.Div("Risk Utilization")
                            ])
                        ], className="ds-card mb-3")
                    ], width=3),
                    dbc.Col([
                        dbc.Card([
                            dbc.CardBody([
                                html.H5("Max Drawdown", className="card-title text-muted"),
                                html.H2(id='max-drawdown', className="text-danger"),
                                html.Div("Peak to Trough")
                            ])
                        ], className="ds-card mb-3")
                    ], width=3),
                ], className="mb-4"),

                dbc.Row([
                    # Active Positions
                    dbc.Col([
                        dbc.Card([
                            dbc.CardHeader("Active Positions"),
                            dbc.CardBody([
                                html.Div(id='active-positions-table')
                            ])
                        ], className="ds-card mb-4")
                    ], width=12)
                ]),

                dbc.Row([
                    # Trade History
                    dbc.Col([
                        dbc.Card([
                            dbc.CardHeader("Recent Trade History"),
                            dbc.CardBody([
                                html.Div(id='trade-history-table')
                            ])
                        ], className="ds-card")
                    ], width=8),
                    
                    # System Health
                    dbc.Col([
                        dbc.Card([
                            dbc.CardHeader("System Health"),
                            dbc.CardBody([
                                html.Div(id='system-health-metrics')
                            ])
                        ], className="ds-card")
                    ], width=4)
                ])
            ]),
            
            # Tab 3: Backtest Lab (Existing)
            dbc.Tab(label="Backtest Lab", tab_id="tab-backtest", children=[
                html.Div("Backtest Lab Content Here") # Placeholder to keep existing logic if needed, or we can copy full content
            ])
        ], id='main-tabs', active_tab='tab-market'),

        # Intervals
        dcc.Interval(id='interval-fast', interval=2000, n_intervals=0),
        dcc.Interval(id='interval-slow', interval=10000, n_intervals=0),

        # Stores
        dcc.Store(id='timeframe-store', data='15m'),
        dcc.Store(id='backtest-result-store'),
        dcc.Store(id='chat-history-store', data=[]),
        
        # Modals
        dbc.Modal([
            dbc.ModalHeader(dbc.ModalTitle(id='backtest-modal-title')),
            dbc.ModalBody(id='backtest-modal-body'),
            dbc.ModalFooter(dbc.Button("Close", id='backtest-modal-close', className="ms-auto", n_clicks=0))
        ], id="backtest-modal", size="lg", is_open=False),

    ], fluid=True, className="p-4")

    app.layout = layout
    return app


# Status Badge Callback
@callback(
    [Output('live-status-badge', 'style'),
     Output('demo-status-badge', 'style'),
     Output('freshness-badge', 'children')],
    [Input('interval-fast', 'n_intervals')]
)
def update_status_badges(n):
    """Update status badges based on data source and freshness."""
    import os

    # Determine mode from environment
    use_sample = os.getenv('DASH_USE_SAMPLE_DATA', '0') == '1'

    # Set badge visibility
    live_style = {'display': 'none'} if use_sample else {'display': 'inline-block'}
    demo_style = {'display': 'inline-block'} if use_sample else {'display': 'none'}

    # Update freshness badge
    freshness_text = f"Data Fresh: < 30s" if not use_sample else "Demo Data"

    return live_style, demo_style, freshness_text


# Main Chart Callback
@callback(
    Output('main-chart', 'figure'),
    [Input('interval-fast', 'n_intervals'),
     Input('timeframe-store', 'data'),
     Input('overlay-toggles', 'value')]
)
def update_main_chart(n_intervals, timeframe, overlay_toggles):
    """Update the main-chart figure based on timeframe and overlay selections."""
    # Use timeframe from store, defaulting to 15m if not set
    timeframe = timeframe or '15m'

    # Fetch market data
    symbol = 'BTCUSDT'
    df, fetch_meta = fetch_market_data(symbol, timeframe, num_bars=500, force_refresh=False)

    # Prepare overlay features
    overlay_toggles = overlay_toggles or []
    features = {
        'liquidity': 'liquidity' in overlay_toggles,
        'supertrend': 'supertrend' in overlay_toggles,
        'orderflow': 'orderflow' in overlay_toggles,
        'chandelier': 'chandelier' in overlay_toggles,
        'regime': False,
        'alignment': False
    }

    # Create chart
    price_fig = create_interactive_chart(df, symbol, timeframe, features)

    logger.info(f"Updated main-chart for {symbol} {timeframe} with overlays: {overlay_toggles}")

    return price_fig


# Timeframe Selection Callback
@callback(
    [Output('timeframe-store', 'data'),
     Output('tf-1m', 'className'),
     Output('tf-5m', 'className'),
     Output('tf-15m', 'className'),
     Output('tf-1h', 'className'),
     Output('tf-4h', 'className'),
     Output('tf-1d', 'className')],
    [Input('tf-1m', 'n_clicks'),
     Input('tf-5m', 'n_clicks'),
     Input('tf-15m', 'n_clicks'),
     Input('tf-1h', 'n_clicks'),
     Input('tf-4h', 'n_clicks'),
     Input('tf-1d', 'n_clicks')]
)
def update_timeframe_selection(n1m, n5m, n15m, n1h, n4h, n1d):
    """Handle timeframe button clicks and update store."""
    import dash

    # Get the callback context to determine which button was clicked
    ctx = dash.callback_context

    if not ctx.triggered:
        # No button clicked yet, return default (15m)
        return '15m', 'tf-btn me-2', 'tf-btn me-2', 'tf-btn active me-2', 'tf-btn me-2', 'tf-btn me-2', 'tf-btn'

    # Determine which button triggered the callback
    button_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # Map button IDs to timeframes
    timeframe_map = {
        'tf-1m': '1m',
        'tf-5m': '5m',
        'tf-15m': '15m',
        'tf-1h': '1h',
        'tf-4h': '4h',
        'tf-1d': '1d'
    }

    selected_timeframe = timeframe_map.get(button_id, '15m')

    # Update button styles to show active state
    tf_1m_class = 'tf-btn active me-2' if button_id == 'tf-1m' else 'tf-btn me-2'
    tf_5m_class = 'tf-btn active me-2' if button_id == 'tf-5m' else 'tf-btn me-2'
    tf_15m_class = 'tf-btn active me-2' if button_id == 'tf-15m' else 'tf-btn me-2'
    tf_1h_class = 'tf-btn active me-2' if button_id == 'tf-1h' else 'tf-btn me-2'
    tf_4h_class = 'tf-btn active me-2' if button_id == 'tf-4h' else 'tf-btn me-2'
    tf_1d_class = 'tf-btn active' if button_id == 'tf-1d' else 'tf-btn'

    return selected_timeframe, tf_1m_class, tf_5m_class, tf_15m_class, tf_1h_class, tf_4h_class, tf_1d_class


@callback(
    Output('portfolio-value', 'children'),
    Output('portfolio-pnl-percent', 'children'),
    Output('unrealized-pnl', 'children'),
    Output('total-exposure', 'children'),
    Output('max-drawdown', 'children'),
    Output('active-positions-table', 'children'),
    Output('trade-history-table', 'children'),
    Output('system-health-metrics', 'children'),
    Input('interval-fast', 'n_intervals')
)
def update_account_tab(n):
    """Update the Account & Trading tab components."""
    if not CHAT_SYSTEM_CONTEXT:
        return "N/A", "", "N/A", "N/A", "N/A", "System Context Not Connected", "No Data", "No Data"

    # Portfolio Metrics
    risk_metrics = CHAT_SYSTEM_CONTEXT.risk_metrics
    portfolio_value = risk_metrics.get('portfolio_value', 0)
    unrealized_pnl = risk_metrics.get('unrealized_pnl', 0)
    total_exposure = risk_metrics.get('total_exposure', 0)
    max_drawdown = risk_metrics.get('max_drawdown', 0)

    # Format Values
    pv_str = f"${portfolio_value:,.2f}"
    upnl_str = f"${unrealized_pnl:,.2f}"
    exp_str = f"{total_exposure:.1%}"
    dd_str = f"{max_drawdown:.1%}"

    # PnL Percent Component
    pnl_pct = (unrealized_pnl / portfolio_value) if portfolio_value > 0 else 0
    pnl_color = "text-success" if pnl_pct >= 0 else "text-danger"
    pnl_comp = html.Div(f"{pnl_pct:+.2%}", className=pnl_color)

    # Active Positions Table
    positions = CHAT_SYSTEM_CONTEXT.active_positions
    if not positions:
        pos_table = html.Div("No active positions", className="text-muted text-center p-3")
    else:
        pos_rows = []
        for symbol, pos in positions.items():
            pnl = pos.get('unrealized_pnl', 0)
            pnl_class = "text-success" if pnl >= 0 else "text-danger"
            pos_rows.append(html.Tr([
                html.Td(symbol),
                html.Td(pos.get('side', 'N/A')),
                html.Td(f"{pos.get('quantity', 0):.4f}"),
                html.Td(f"${pos.get('entry_price', 0):,.2f}"),
                html.Td(f"${pnl:,.2f}", className=pnl_class),
            ]))
        
        pos_table = html.Table([
            html.Thead(html.Tr([html.Th("Symbol"), html.Th("Side"), html.Th("Size"), html.Th("Entry"), html.Th("PnL")])),
            html.Tbody(pos_rows)
        ], className="table table-dark table-hover")

    # Trade History Table
    history = CHAT_SYSTEM_CONTEXT.trade_history
    if not history:
        hist_table = html.Div("No trade history", className="text-muted text-center p-3")
    else:
        hist_rows = []
        # Show last 10 trades
        for trade in reversed(history[-10:]):
            pnl = trade.pnl
            pnl_class = "text-success" if pnl >= 0 else "text-danger"
            hist_rows.append(html.Tr([
                html.Td(trade.exit_time.strftime("%H:%M")),
                html.Td(trade.symbol),
                html.Td(trade.side),
                html.Td(f"${pnl:,.2f}", className=pnl_class),
                html.Td(trade.exit_reason)
            ]))
            
        hist_table = html.Table([
            html.Thead(html.Tr([html.Th("Time"), html.Th("Symbol"), html.Th("Side"), html.Th("PnL"), html.Th("Reason")])),
            html.Tbody(hist_rows)
        ], className="table table-dark table-sm")

    # System Health
    health = CHAT_SYSTEM_CONTEXT.system_health
    health_metrics = html.Div([
        html.Div([html.Span("Memory:"), html.Span(f"{health.get('memory_usage', 0):.1f} MB", className="float-end")]),
        html.Div([html.Span("CPU:"), html.Span(f"{health.get('cpu_usage', 0):.1f}%", className="float-end")]),
        html.Div([html.Span("Errors:"), html.Span(f"{len(health.get('errors', []))}", className="float-end text-danger" if health.get('errors') else "float-end text-success")]),
        html.Div([html.Span("Last Check:"), html.Span(health.get('last_check', datetime.now()).strftime("%H:%M:%S"), className="float-end text-muted", style={'fontSize': '12px'})], className="mt-2")
    ])

    return pv_str, pnl_comp, upnl_str, exp_str, dd_str, pos_table, hist_table, health_metrics

# Removed duplicate callback - using update_chat() at line 3292 instead
@callback(
    Output('chat-history-store', 'data'),
    Output('chat-history', 'children'),
    Output('chat-input', 'value'),
    Output('debug-output', 'children'),
    Input('chat-send-btn', 'n_clicks'),
    State('chat-input', 'value'),
    State('chat-history-store', 'data')
)
def handle_chat_interaction(n_clicks, message_text, chat_history):
    """Handle chat interaction."""
    logger.info(f"DEBUG: Callback received - n_clicks={n_clicks}, message_text='{message_text}', chat_history_len={len(chat_history) if chat_history else 0}")

    # Ignore initial render and empty clicks
    if not n_clicks:
        logger.info("DEBUG: Chat not sent yet")
        return dash.no_update, dash.no_update, dash.no_update, "Awaiting message"

    if not message_text or not str(message_text).strip():
        logger.info(f"DEBUG: Empty message text, returning early")
        return dash.no_update, dash.no_update, dash.no_update, "No message"

    logger.info(f"DEBUG: Processing message: {message_text[:50]}...")

    try:
        updated_history, rendered_history, status = process_chat_request(
            chat_history,
            message_text,
            message_type="strategy"
        )
        logger.info(f"DEBUG: Processed chat. History len: {len(updated_history)} | Status: {status}")
        return updated_history, rendered_history, "", status
    except Exception as exc:
        logger.exception("Chat processing failed")
        fallback_history = (chat_history or []) + [{
            'text': f"Chat processing failed: {exc}",
            'is_user': False,
            'timestamp': datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
        }]
        return fallback_history, render_chat_history(fallback_history), dash.no_update, f"Error: {exc}"

# Entry point for running the dashboard
if __name__ == "__main__":
    import sys
    import os

    # Ensure we're using the correct path
    sys.path.insert(0, '/Users/mrsmoothy/Downloads/Trading_bot')

    # Initialize real SystemContext
    try:
        from core.system_context import SystemContext
        system_context = SystemContext()
        set_system_context(system_context)
        print("âœ“ Real SystemContext initialized")
    except Exception as e:
        print(f"âš  Warning: Could not initialize SystemContext: {e}")
        print("  Dashboard will run with limited functionality")
        # Create minimal fallback context
        class MinimalContext:
            def __init__(self):
                self.overlay_state = {
                    "liquidity": True,
                    "supertrend": True,
                    "orderflow": True,
                    "chandelier": False,
                    "regime": False,
                    "alignment": False
                }
                self.system_health = {
                    "memory_usage": 0,
                    "cpu_usage": 0,
                    "errors": [],
                    "last_check": datetime.now(),
                }
                self.risk_metrics = {
                    "portfolio_value": 100000.0,
                    "unrealized_pnl": 0.0,
                    "total_exposure": 0.0,
                    "max_drawdown": 0.0,
                }
        set_system_context(MinimalContext())

    # Check for demo/live mode
    use_sample = os.getenv('DASH_USE_SAMPLE_DATA', '0') == '1'
    mode = "DEMO MODE" if use_sample else "LIVE MODE"

    # Create and run the app
    print(f"\n{'='*60}")
    print(f"  DeepSeek Trading Dashboard - {mode}")
    print(f"{'='*60}")
    print(f"  URL: http://127.0.0.1:8050")
    print(f"  Data: {'Demo/Sample Data' if use_sample else 'Binance Testnet API'}")
    print(f"{'='*60}\n")

    app = create_dashboard_app()
    app.run(host='0.0.0.0', port=8050, debug=False, dev_tools_ui=False)
